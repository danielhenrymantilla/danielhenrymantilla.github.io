<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Globals on Another one bytes the Rust!</title><link>https://danielhenrymantilla.github.io/tags/globals/</link><description>Recent content in Globals on Another one bytes the Rust!</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 24 Feb 2019 16:45:15 +0100</lastBuildDate><atom:link href="https://danielhenrymantilla.github.io/tags/globals/index.xml" rel="self" type="application/rss+xml"/><item><title>Mutation - part 2: To mut or not to mut</title><link>https://danielhenrymantilla.github.io/posts/2019-02-24-mutation-part-2-to-mut-or-not-to-mut/</link><pubDate>Sun, 24 Feb 2019 16:45:15 +0100</pubDate><guid>https://danielhenrymantilla.github.io/posts/2019-02-24-mutation-part-2-to-mut-or-not-to-mut/</guid><description>Prelude From the previous post: A (runtime) variable is a (static) binding to some place in memory, and is used to read/write from/into that place in memory
Let&amp;rsquo;s illustrate it again with an example.
The following code
fn foo(){letx=42;lety=i32::wrapping_add(x,27)asu8;}
unsugars to1:
fn foo(){// allocate 4 bytes in the stack frame &amp;amp; bind at_x to its address letx: i32;// type inferred // allocate 1 byte in the stack frame &amp;amp; bind at_y to its address lety: u8;// type inferred *at_x=42;*at_y=i32::wrapping_add(*at_x,27)asu8;} So, whenever there is a variable var, the actual binding is from at_var to some address in memory, and var is just sugar for *at_var2.</description></item></channel></rss>