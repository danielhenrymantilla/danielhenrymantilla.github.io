<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Programming on Another one bytes the Rust!</title><link>https://danielhenrymantilla.github.io/categories/programming/</link><description>Recent content in Programming on Another one bytes the Rust!</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 24 Feb 2019 16:45:15 +0100</lastBuildDate><atom:link href="https://danielhenrymantilla.github.io/categories/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Mutation - part 2: To mut or not to mut</title><link>https://danielhenrymantilla.github.io/posts/2019-02-24-mutation-part-2-to-mut-or-not-to-mut/</link><pubDate>Sun, 24 Feb 2019 16:45:15 +0100</pubDate><guid>https://danielhenrymantilla.github.io/posts/2019-02-24-mutation-part-2-to-mut-or-not-to-mut/</guid><description>Prelude From the previous post: A (runtime) variable is a (static) binding to some place in memory, and is used to read/write from/into that place in memory
Let&amp;rsquo;s illustrate it again with an example.
The following code
fn foo(){letx=42;lety=i32::wrapping_add(x,27)asu8;}
unsugars to1:
fn foo(){// allocate 4 bytes in the stack frame &amp;amp; bind at_x to its address letx: i32;// type inferred // allocate 1 byte in the stack frame &amp;amp; bind at_y to its address lety: u8;// type inferred *at_x=42;*at_y=i32::wrapping_add(*at_x,27)asu8;} So, whenever there is a variable var, the actual binding is from at_var to some address in memory, and var is just sugar for *at_var2.</description></item><item><title>Mutation - Part 1: Variables</title><link>https://danielhenrymantilla.github.io/posts/2019-02-19-mutation-part-1-variables/</link><pubDate>Sun, 17 Feb 2019 15:07:48 +0100</pubDate><guid>https://danielhenrymantilla.github.io/posts/2019-02-19-mutation-part-1-variables/</guid><description>What is a variable? Ok, here there is really a lot that could be said, and a simple blog post will not cover it. I will just talk about two important and distinct thinking patterns involved:
the idea of binding a name to a value;
the idea of reading/writing values from/into memory;
1. Identity binding The best example in Rust for &amp;ldquo;just a binding&amp;rdquo; (i.e., with no backing memory) is const</description></item><item><title>Mutation - Part 0: Intro</title><link>https://danielhenrymantilla.github.io/posts/2019-02-19-mutation-part-0-intro/</link><pubDate>Sun, 17 Feb 2019 15:07:47 +0100</pubDate><guid>https://danielhenrymantilla.github.io/posts/2019-02-19-mutation-part-0-intro/</guid><description>For a first programming post, I have chosen an innocent-looking topic, regarding Rust&amp;rsquo;s mut keyword:
What does mut truly mean? what does it do? For starters, let&amp;rsquo;s quote TRPL1:
Mutability, the ability to change something
Hum, it looks like they got it the other way around. Let&amp;rsquo;s fix it:
Mutability, the ability to change something
Mutability, the property of being change-able
Note the change in the grammatical aspect: if a mutator modifies a mutatee, the mutability required for it to be possible is the mutatee&amp;rsquo;s one (and not the mutator&amp;rsquo;s).</description></item></channel></rss>