<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=//gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.49.2"><meta name=viewport content="width=device-width,initial-scale=1"><title>Mutation - part 2: To mut or not to mut &middot; Another one bytes the Rust!</title><link type=text/css rel=stylesheet href=https://danielhenrymantilla.github.io/css/prev-next_buttons.css><link type=text/css rel=stylesheet href=https://danielhenrymantilla.github.io/css/inline_svgs.css><link rel=stylesheet type=text/css href=https://danielhenrymantilla.github.io/css/asciinema_player.css><link type=text/css rel=stylesheet href=https://danielhenrymantilla.github.io/css/print.css media=print><link type=text/css rel=stylesheet href=https://danielhenrymantilla.github.io/css/poole.css><link type=text/css rel=stylesheet href=https://danielhenrymantilla.github.io/css/syntax.css><link type=text/css rel=stylesheet href=https://danielhenrymantilla.github.io/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><link href rel=alternate type=application/rss+xml title="Another one bytes the Rust!"></head><body class="theme-base-08 layout-reverse"><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://danielhenrymantilla.github.io/><h1>Another one bytes the Rust!</h1></a><p class=lead>Thoughts and ramblings for the like-minded</p></div><nav><ul class=sidebar-nav><li><a href=https://danielhenrymantilla.github.io/>Home</a></li><li><a href=/series>Blog Post Series</a></li><li><a href=/categories>Categories</a></li><li><a href=/tags>Tags</a></li></ul></nav><p>&copy; 2019. All rights reserved.</p></div></aside><main class="content container"><div class=prev-next><a class="prev-next-link prev-link" href=/posts/2019-02-19-mutation-part-1-variables/><button class="button prev-button">
<span>Prev post</span></button></a>
<a class="prev-next-link next-link" href=/posts/2019-03-03-mutation-part-3-interior-mutability/><button class="button next-button">
<span>Next post</span></button></a></div><div class=post><h1>Mutation - part 2: To mut or not to mut</h1><time datetime=2019-02-24T16:45:15&#43;0100 class=post-date>Sun, Feb 24, 2019</time><h2 id=prelude>Prelude</h2><h3 id=from-the-previous-post>From the <a href=/posts/2019-02-19-mutation-part-1-variables/>previous post</a>:</h3><blockquote><p>A (runtime) variable is a (static) binding to some place in memory, and is <em>used</em> to read/write from/into that place in memory</p></blockquote><p>Let&rsquo;s illustrate it again with an example.</p><p>The following code</p><a class=inline-svg href="https://play.rust-lang.org/?edition=2018&code=fn%20foo%20%28%29%0a%7b%0a%20%20%20%20let%20x%20%3d%2042%3b%0a%20%20%20%20let%20y%20%3d%20i32%3a%3awrapping_add%28x%2c%2027%29%20as%20u8%3b%0a%7d%0a" target=_blank><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="#606060" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>foo</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>x<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>42</span>;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>y<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>i32</span>::wrapping_add(x,<span style=color:#bbb> </span><span style=color:#00d;font-weight:700>27</span>)<span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>u8</span>;<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><p>unsugars to<sup class=footnote-ref id=fnref:1><a href=#fn:1>1</a></sup>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>foo</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#888>// allocate 4 bytes in the stack frame &amp; bind at_x to its address
</span><span style=color:#888></span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>x: <span style=color:#339;font-weight:700>i32</span>;<span style=color:#bbb>  </span><span style=color:#888>// type inferred
</span><span style=color:#888></span><span style=color:#bbb>    </span><span style=color:#888>// allocate 1 byte in the stack frame &amp; bind at_y to its address
</span><span style=color:#888></span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>y:  <span style=color:#339;font-weight:700>u8</span>;<span style=color:#bbb>  </span><span style=color:#888>// type inferred
</span><span style=color:#888></span><span style=color:#bbb>    </span><span style=color:#333>*</span>at_x<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>42</span>;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#333>*</span>at_y<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>i32</span>::wrapping_add(<span style=color:#333>*</span>at_x,<span style=color:#bbb> </span><span style=color:#00d;font-weight:700>27</span>)<span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>u8</span>;<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><blockquote><p>So, whenever there is a variable <code>var</code>, the actual binding is from <code>at_var</code> to some address in memory, and <strong><code>var</code> is just sugar for <code>*at_var</code></strong><sup class=footnote-ref id=fnref:2><a href=#fn:2>2</a></sup>.</p></blockquote><h1 id=to-mut-or-not-to-mut>To <code>mut</code> or not to <code>mut</code></h1><blockquote><p>What does the keyword <code>mut</code> really mean?</p></blockquote><h2 id=1-mut-bindings>1) <code>mut</code> bindings</h2><p>When used with a variable binding, it expresses to the compiler the programmer&rsquo;s intent of potentially <strong>mutating the data owned</strong> by that variable (<em>i.e.</em>, mutating either the very contents of that variable, or the data recursively owned by that content (<em>e.g.</em>, a <code>Box</code>)).</p><ul><li><p>For <em>local</em> variables, this is more of a lint, to warn against accidental mutations;
<strong>local memory is always mutable!</strong> (since it is in the stack, which is writeable).</p><ul><li><p>This means that transmuting an immutable reference to stack data into a mutable reference should never cause a memory violation (<a href=#mut-const>neither does it in C</a>).</p><p>Test, for instance, the following code:
<a class=inline-svg href="https://play.rust-lang.org/?edition=2018&code=fn%20main%20%28%29%0a%7b%0a%20%20%20%20let%20x%3a%20i32%20%3d%2042%3b%20%2f%2f%20immutable%3f%0a%20%20%20%20let%20at_x_mut%3a%20%26mut%20i32%20%3d%20unsafe%20%7b%0a%20%20%20%20%20%20%20%20%26mut%20%2a%28%26x%20as%20%2aconst%20i32%20as%20%2amut%20i32%29%0a%20%20%20%20%7d%3b%0a%20%20%20%20%2aat_x_mut%20%2b%3d%2027%3b%0a%20%20%20%20assert%21%28x%20%21%3d%2042%29%3b%0a%20%20%20%20dbg%21%28x%29%3b%0a%7d%0a" target=_blank><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="#606060" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>main</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>x: <span style=color:#339;font-weight:700>i32</span> <span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>42</span>;<span style=color:#bbb> </span><span style=color:#888>// immutable?
</span><span style=color:#888></span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>at_x_mut: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>i32</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>unsafe</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#333>*</span>(<span style=color:#333>&amp;</span>x<span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#333>*</span><span style=color:#080;font-weight:700>const</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>i32</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#333>*</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>i32</span>)<span style=color:#bbb>
</span><span style=color:#bbb>    </span>};<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#333>*</span>at_x_mut<span style=color:#bbb> </span><span style=color:#333>+=</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>27</span>;<span style=color:#bbb>
</span><span style=color:#bbb>    </span>assert<span style=color:#333>!</span>(x<span style=color:#bbb> </span><span style=color:#333>!=</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>42</span>);<span style=color:#bbb>
</span><span style=color:#bbb>    </span>dbg<span style=color:#333>!</span>(x);<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div></p><p>However, this is still <em>Undefined Behavior</em><sup class=footnote-ref id=fnref:3><a href=#fn:3>3</a></sup>, so <strong>do not do this at home</strong> (nor at work)!</p></li></ul></li><li><p>But for <em>global</em> variables, a <code>mut</code> binding can make the compiler choose to place a <code>static</code> in the writeable part of the global memory (<code>.data</code>/<code>.bss</code> segment) instead of<sup class=footnote-ref id=fnref:4><a href=#fn:4>4</a></sup> the readonly part (<code>.rodata</code>).</p><ul><li><p>This means that transmuting an immutable reference to <code>static</code> data into a mutable reference can cause a memory violation.</p><p>Test, for instance, the following code:
<a class=inline-svg href="https://play.rust-lang.org/?edition=2018&code=%2f%2f%21%20This%20should%20fail%0a%0afn%20main%20%28%29%0a%7b%0a%20%20%20%20static%20x%3a%20i32%20%3d%2042%3b%20%2f%2f%20immutable%21%0a%20%20%20%20let%20at_x_mut%3a%20%26mut%20i32%20%3d%20unsafe%20%7b%0a%20%20%20%20%20%20%20%20%26mut%20%2a%28%26x%20as%20%2aconst%20i32%20as%20%2amut%20i32%29%0a%20%20%20%20%7d%3b%0a%20%20%20%20%2aat_x_mut%20%2b%3d%2027%3b%20%2f%2f%20Segmentation%20Fault%0a%20%20%20%20unreachable%21%28%22Previous%20line%20segfaulted%22%29%3b%0a%7d%0a" target=_blank><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="#606060" d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937.0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154.0l239.94 416.028zM288 354c-25.405.0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346 7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373.0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884.0-12.356 5.78-11.981 12.654z"/></svg></a><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>main</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>static</span><span style=color:#bbb> </span>x: <span style=color:#339;font-weight:700>i32</span> <span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>42</span>;<span style=color:#bbb> </span><span style=color:#888>// immutable!
</span><span style=color:#888></span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>at_x_mut: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>i32</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>unsafe</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#333>*</span>(<span style=color:#333>&amp;</span>x<span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#333>*</span><span style=color:#080;font-weight:700>const</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>i32</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#333>*</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>i32</span>)<span style=color:#bbb>
</span><span style=color:#bbb>    </span>};<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#333>*</span>at_x_mut<span style=color:#bbb> </span><span style=color:#333>+=</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>27</span>;<span style=color:#bbb> </span><span style=color:#888>// Segmentation Fault
</span><span style=color:#888></span><span style=color:#bbb>    </span>unreachable<span style=color:#333>!</span>(<span style=background-color:#fff0f0>&#34;Previous line segfaulted&#34;</span>);<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div></p></li></ul><p>See <a href=#data-rodata>Appendix 2 - readonly vs writeable <code>static</code>s</a>.</p></li></ul><p>As said before, the &ldquo;compiler deny mutation lint&rdquo; applies transitively to data pointed to in an owning manner, such as through a <code>Box</code>.</p><ul><li><p>For instance, <code>rustc</code> will <a href="https://play.rust-lang.org/?gist=11d902d195f591d76c072ea93835224c">refuse to compile</a>
the following code:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30</span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>main</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">32</span><span style=color:#bbb>    </span><span style=color:#888>// immutable?
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">33</span><span style=color:#888></span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>at_thing<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#007020>Box</span>::<span style=color:#333>&lt;</span>Thing<span style=color:#333>&gt;</span>::default();<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">34</span><span style=color:#bbb>    </span>print<span style=color:#333>!</span>(<span style=background-color:#fff0f0>&#34;Before:</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>  {:?}</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>After:</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>  &#34;</span>,<span style=color:#bbb> </span><span style=color:#333>*</span>at_thing);<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">35</span><span style=color:#bbb>    </span>mutate(<span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#333>*</span>at_thing);<span style=color:#bbb> </span><span style=color:#888>// cannot borrow as mutable
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">36</span><span style=color:#888></span>}<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">37</span><span style=color:#bbb></span></code></pre></div></li><li><p>But <a href="https://play.rust-lang.org/?gist=28e9c44faf5d71047effdf8e98b4d26a">by adding a couple of braces it compiles</a>
(without any <code>unsafe</code> whatsoever!):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30</span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>main</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">32</span><span style=color:#bbb>    </span><span style=color:#888>// immutable?
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">33</span><span style=color:#888></span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>at_thing<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#007020>Box</span>::<span style=color:#333>&lt;</span>Thing<span style=color:#333>&gt;</span>::default();<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">34</span><span style=color:#bbb>    </span>print<span style=color:#333>!</span>(<span style=background-color:#fff0f0>&#34;Before:</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>  {:?}</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>After:</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>  &#34;</span>,<span style=color:#bbb> </span><span style=color:#333>*</span>at_thing);<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">35</span><span style=color:#bbb>    </span>mutate(<span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#333>*</span>{at_thing});<span style=color:#bbb> </span><span style=color:#888>// notice the braces
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">36</span><span style=color:#888></span>}<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">37</span><span style=color:#bbb></span></code></pre></div><ul><li><p>displaying:</p><pre><code>Before:
  Thing at 0x559f5e50ea40 { mutated: false }
After:
  Thing at 0x559f5e50ea40 { mutated: true }
</code></pre></li></ul></li></ul><p>You may then ask:</p><blockquote><p>Why? How?</p></blockquote><p>Mainly because:</p><blockquote><h3 id=the-mut-modifier-applies-to-the-binding-itself-not-the-memory-it-binds-to>the <code>mut</code> modifier applies to the binding itself, not the memory it binds to!</h3></blockquote><p>This is actually one of the main non obvious points that I wanted to talk about within this blog post series.</p><p>Let&rsquo;s simplify the previous example into the following:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>ptr1<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#007020>Box</span>::new(<span style=color:#00d;font-weight:700>42_</span><span style=color:#080;font-weight:700>u8</span>);<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#888>/****** Error, cannot borrow as mutable *******/</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#888>// *ptr1 += 27;        // mutation of the data in the heap
</span><span style=color:#888>// ptr1 = Box::new(0); // mutation of the pointer itself
</span><span style=color:#888></span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>ptr2<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>ptr1;<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#333>*</span>ptr2<span style=color:#bbb> </span><span style=color:#333>+=</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>27</span>;<span style=color:#bbb>        </span><span style=color:#888>// mutation of the data in the heap
</span><span style=color:#888></span>ptr2<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#007020>Box</span>::new(<span style=color:#00d;font-weight:700>0</span>);<span style=color:#bbb> </span><span style=color:#888>// mutation of the pointer itself
</span><span style=color:#888></span></code></pre></div><ol><li><p>At least one byte is heap-allocated and
initialised with the value <code>42</code>.</p></li><li><p>The pointer to the allocated byte is then stored in a local variable <code>ptr1</code>, <strong>immutably bound</strong> (no <code>mut</code> qualifier in the binding declaration);</p></li><li><p>This makes mutation through the <code>ptr1</code> binding &ldquo;impossible&rdquo; (refused by the compiler), even through one level of indirection, because that indirection <em>owns</em> its data.</p></li><li><p>By moving the pointer into another<sup class=footnote-ref id=fnref:5><a href=#fn:5>5</a></sup> local variable, we have the chance to declare a new binding, this time <code>mut</code>-able. <strong>The data in the heap has not moved</strong>.</p></li><li><p>Mutation is now possible, <em>both</em> to the pointee (value in the heap) and the pointer (value in the stack).</p></li></ol><p>Now you can understand why the code with the braces compiled and worked:</p><ul><li><p><code>{var}</code> is a very short way of writing down the following code:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>inner_var<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>var;<span style=color:#bbb>  </span><span style=color:#888>// var is moved *into* the scope
</span><span style=color:#888></span><span style=color:#bbb>    </span>inner_var<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb> </span><span style=color:#888>// the whole braced expr. evaluates to the moved value of `var`
</span><span style=color:#888>// but has no (explicit) binding: it is anonymously bound.
</span><span style=color:#888></span></code></pre></div><p><em>i.e.</em>, <code>{var}</code> can be a trick to extract the value of <code>var</code> without the binding</p><blockquote><p>but if the <code>mut</code>-ability of a variable is defined when bound,
<em>quid</em> of anonymous expressions?</p></blockquote></li><li><p><strong>an anonymous binding is always <code>mut</code></strong>!</p><ul><li><p>This is what allows you to write, for instance, things such as:
<a class=inline-svg href="https://play.rust-lang.org/?edition=2018&code=use%20%3a%3astd%3a%3aprocess%3a%3aCommand%3b%0a%0afn%20run%20%28%0a%20%20%20%20command%3a%20%26mut%20Command%2c%0a%29%20-%3e%20String%0a%7b%0a%20%20%20%20String%3a%3afrom_utf8%28%0a%20%20%20%20%20%20%20%20command%0a%20%20%20%20%20%20%20%20%20%20%20%20.output%28%29%0a%20%20%20%20%20%20%20%20%20%20%20%20.expect%28%22Failed%20to%20execute%20process%22%29%0a%20%20%20%20%20%20%20%20%20%20%20%20.stdout%0a%20%20%20%20%29.expect%28%22Invalid%20UTF8%20output%22%29%0a%7d%0a%0a%0afn%20main%20%28%29%0a%7b%0a%20%20%20%20print%21%28%22%7b%7d%22%2c%20run%28%0a%20%20%20%20%20%20%20%20Command%3a%3anew%28%22sh%22%29%20%20%2f%2f%20anonymous%20%60Command%60%0a%20%20%20%20%20%20%20%20%20%20%20%20.arg%28%22-c%22%29%20%20%20%20%20%20%2f%2f%20takes%20a%20%60%26mut%20Command%60%0a%20%20%20%20%20%20%20%20%20%20%20%20.arg%28%22echo%20Hello%2c%20World%21%22%29%0a%20%20%20%20%29%29%3b%0a%7d%0a" target=_blank><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="#606060" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span style=color:#080;font-weight:700>use</span><span style=color:#bbb> </span>::std::process::Command;<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>run</span><span style=color:#bbb> </span>(<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span style=color:#bbb>    </span>command: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>mut</span><span style=color:#bbb> </span>Command,<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span style=color:#bbb></span>)<span style=color:#bbb> </span>-&gt; <span style=color:#007020>String</span>
<span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span>{<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span style=color:#bbb>    </span><span style=color:#007020>String</span>::from_utf8(<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span style=color:#bbb>        </span>command<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span style=color:#bbb>            </span>.output()<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span style=color:#bbb>            </span>.expect(<span style=background-color:#fff0f0>&#34;Failed to execute process&#34;</span>)<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span style=color:#bbb>            </span>.stdout<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span style=color:#bbb>    </span>).expect(<span style=background-color:#fff0f0>&#34;Invalid UTF8 output&#34;</span>)<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>main</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span style=color:#bbb>    </span>print<span style=color:#333>!</span>(<span style=background-color:#fff0f0>&#34;{}&#34;</span>,<span style=color:#bbb> </span>run(<span style=color:#bbb>
</span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span style=color:#bbb>        </span>Command::new(<span style=background-color:#fff0f0>&#34;sh&#34;</span>)<span style=color:#bbb>  </span><span style=color:#888>// anonymous `Command`
</span></span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span style=color:#888></span><span style=color:#bbb>            </span>.arg(<span style=background-color:#fff0f0>&#34;-c&#34;</span>)<span style=color:#bbb>      </span><span style=color:#888>// takes a `&amp;mut Command`
</span></span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span style=color:#888></span><span style=color:#bbb>            </span>.arg(<span style=background-color:#fff0f0>&#34;echo Hello, World!&#34;</span>)<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span style=color:#bbb>    </span>));<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span style=color:#bbb></span></code></pre></div></p><p>If you look at the <code>main</code> function, lines <code>19</code> and <code>20</code>,
you will notice that the anonymously bound <code>Command::new(&quot;sh&quot;)</code> is fed to the
<code>.arg()</code> method, which takes a <code>&amp;mut Command</code>.
This means Rust does allow taking a <code>&amp;mut</code> reference of an anonymously bound expression.</p></li></ul></li></ul><h2 id=2-mut-references>2) <code>&amp;mut _</code> references</h2><p>There is a very short definition for this:</p><blockquote><h3 id=a-mut-t-reference-is-a-valid-pointer-to-a-t-that-is-statically-guaranteed-to-be-unique>A <code>&amp;mut T</code> reference is a <em>valid</em> pointer to a <code>T</code> that is <em>statically guaranteed to be unique</em>.</h3></blockquote><p>That&rsquo;s it. No more&hellip; no less! <code>&amp;mut _</code> is all about the <em>uniqueness</em> of the pointer!
In other words, it is <em>guaranteed by design</em> that <strong>during the existence of a <code>&amp;mut</code> reference <code>p</code>, the only way to access <code>*p</code></strong> (the data pointed to) <strong>is through <code>p</code></strong>. I will often call such reference <strong><code>&amp;unique</code></strong> instead of <code>&amp;mut</code> to emphasize this point.</p><blockquote><p>But isn&rsquo;t <code>&amp;mut _</code> a <em>mutable</em> reference?</p></blockquote><p>No. <code>&amp;mut _</code> is a <em>unique</em> (and valid) reference! It just so happens that uniqueness is such a strong guarantee, that Rust allows mutation through such a reference &ldquo;for free&rdquo;.</p><p>To see how this is granted, look at the following <code>safe</code> function, one of the <a href=https://doc.rust-lang.org/core/index.html><code>core</code> features of the language</a>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#888>// core::mem {
</span><span style=color:#888></span><span style=color:#bbb>    </span><span style=color:#d42;background-color:#fff0f0>/// Swaps the values at two uniquely referenced locations,
</span><span style=color:#d42;background-color:#fff0f0></span><span style=color:#bbb>    </span><span style=color:#d42;background-color:#fff0f0>/// without deinitializing either one.
</span><span style=color:#d42;background-color:#fff0f0></span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>swap</span><span style=color:#bbb> </span><span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>(p1: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>unique</span><span style=color:#bbb> </span>T,<span style=color:#bbb> </span>p2: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>unique</span><span style=color:#bbb> </span>T);<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#888>// note: Rust `&amp;mut _` semantics guarantee that `p1 != p2`
</span><span style=color:#888>// }
</span><span style=color:#888></span></code></pre></div><p>This means that whenever a type <code>T</code> is inhabited with at least<sup class=footnote-ref id=fnref:6><a href=#fn:6>6</a></sup> <code>2</code> different values, it is then possible to use a <code>&amp;unique</code> reference to mutate a value of type <code>T</code> and observe the difference.</p><p>Hence the <code>mut</code> in <code>&amp;mut _</code>.</p><p>But <code>&amp;unique</code> is not the only &ldquo;mutable&rdquo; reference in Rust. There are infinitely more.
For instance, the relation &ldquo;unique-reference-to&rdquo; is transitive<sup class=footnote-ref id=fnref:7><a href=#fn:7>7</a></sup>, thus making a unique reference to a unique reference to some <code>x</code> effectively a unique reference to that <code>x</code>:</p><a class=inline-svg href="https://play.rust-lang.org/?edition=2018&code=fn%20swap%3cT%3e%20%28at_p1%3a%20%26mut%20%26mut%20T%2c%20at_p2%3a%20%26mut%20%26mut%20T%29%0a%7b%0a%20%20%20%20core%3a%3amem%3a%3aswap%28%26mut%20%2a%28%2aat_p1%29%2c%20%26mut%20%2a%28%2aat_p2%29%29%0a%7d%0a" target=_blank><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="#606060" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>swap</span><span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>(at_p1: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>T,<span style=color:#bbb> </span>at_p2: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>T)<span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span>core::mem::swap(<span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#333>*</span>(<span style=color:#333>*</span>at_p1),<span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#333>*</span>(<span style=color:#333>*</span>at_p2))<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><p>Which means that <code>&amp;unique &amp;unique T</code> is also a mutable &ldquo;reference&rdquo; to some <code>T</code>.</p><p>On the other hand, it is easy to break the uniqueness of a nested reference; when the inner reference is not unique (<em>e.g.</em> <code>&amp; _</code> reference, or <code>Rc&lt;_&gt;</code>), then a unique reference to such (potentially) non-unique reference is (potentially) non-unique:</p><a class=inline-svg href="https://play.rust-lang.org/?edition=2018&code=%2f%2f%21%20This%20should%20fail%0a%0afn%20swap%3cT%3e%20%28at_p1%3a%20%26mut%20%26T%2c%20at_p2%3a%20%26mut%20%26T%29%0a%7b%0a%20%20%20%20%2f%2f%20although%20at_p1%20%21%3d%20at_p2%2c%20it%20is%20possible%20that%20%2aat_p1%20%3d%3d%20%2aat_p2%0a%20%20%20%20core%3a%3amem%3a%3aswap%28%26mut%20%2a%28%2aat_p1%29%2c%20%26mut%20%2a%28%2aat_p2%29%29%0a%7d%0a" target=_blank><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="#606060" d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937.0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154.0l239.94 416.028zM288 354c-25.405.0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346 7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373.0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884.0-12.356 5.78-11.981 12.654z"/></svg></a><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>swap</span><span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>(at_p1: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span>T,<span style=color:#bbb> </span>at_p2: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span>T)<span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#888>// although at_p1 != at_p2, it is possible that *at_p1 == *at_p2
</span><span style=color:#888></span><span style=color:#bbb>    </span>core::mem::swap(<span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#333>*</span>(<span style=color:#333>*</span>at_p1),<span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#333>*</span>(<span style=color:#333>*</span>at_p2))<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><p>So far we have seen that any kind of unique reference is a mutable reference, <em>i.e.</em>, a reference that allows mutation through it.</p><blockquote><p>Is it the <em>sole</em><sup class=footnote-ref id=fnref:8><a href=#fn:8>8</a></sup> form of mutable reference?</p></blockquote><p>If that were the case, there would be programming idioms that would not be expressable in Rust, such as any form of multi-threaded mutation; which would be a pity since by paying a runtime cost (<em>e.g.</em>, locks) it is a safe and acceptable programming construct.</p><blockquote><p>Well, that&rsquo;s what <code>unsafe</code> is for, isn&rsquo;t it? To use constructs the compiler cannot prove to be safe, and force it to trust the code within the <code>unsafe</code> block. Then I could simply <strong>transmute an immutable reference into a mutable one</strong>, which <em>should be safe as long as the code is guarded by sound runtime checks</em>, right?</p></blockquote><p>Let me show a picture of yourself and your program after such <code>unsafe transmute</code>:</p><p><img src=/img/this_is_fine_UB.jpg alt="Undefined Behavior"></p><blockquote><p>What? But I told you I have this awesome safety checks and super sound invariants that cannot be broken!!</p></blockquote><p>It. Doesn&rsquo;t. Even. Matter. Hell, even the following <code>transmute</code><sup class=footnote-ref id=fnref:9><a href=#fn:9>9</a></sup> is UB:</p><a class=inline-svg href="https://play.rust-lang.org/?edition=2018&code=%2f%2f%21%20This%20should%20fail%0a%0a%23%21%5ballow%28%0a%20%20%20%20mutable_transmutes%2c%20%2f%2f%20let%20MIRI%20spot%20the%20Undefined%20Behavior%0a%20%20%20%20non_snake_case%2c%0a%29%5d%0a%0afn%20swap_UB%3cT%3e%20%28at_x%3a%20%26mut%20T%2c%20at_y%3a%20%26mut%20T%29%0a%7b%0a%20%20%20%20%2f%2f%20for%20fun%2c%20let%20us%20temporarily%20downgrade%20our%20%60%26mut%20T%60%20into%20a%20%60%26T%60%0a%20%20%20%20let%20at_x%3a%20%26T%20%3d%20%26%20%2aat_x%3b%0a%20%20%20%20%2f%2f%20now%2c%20let%27s%20upgrade%20it%20back%3a%0a%20%20%20%20let%20at_x%3a%20%26mut%20T%20%3d%20unsafe%20%7b%0a%20%20%20%20%20%20%20%20core%3a%3amem%3a%3atransmute%3a%3a%3c%26T%2c%20%26mut%20T%3e%28at_x%29%0a%20%20%20%20%7d%3b%0a%20%20%20%20core%3a%3amem%3a%3aswap%28at_x%2c%20at_y%29%3b%0a%7d%0a%0afn%20main%20%28%29%20%7b%20swap_UB%28%26mut%2042%2c%20%26mut%200%29%20%7d%0a" target=_blank><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="#606060" d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937.0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154.0l239.94 416.028zM288 354c-25.405.0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346 7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373.0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884.0-12.356 5.78-11.981 12.654z"/></svg></a><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#579>#![allow(
</span><span style=color:#579>    mutable_transmutes, // let MIRI spot the Undefined Behavior
</span><span style=color:#579>    non_snake_case,
</span><span style=color:#579>)]</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>swap_UB</span><span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>(at_x: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>mut</span><span style=color:#bbb> </span>T,<span style=color:#bbb> </span>at_y: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>mut</span><span style=color:#bbb> </span>T)<span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#888>// for fun, let us temporarily downgrade our `&amp;mut T` into a `&amp;T`
</span><span style=color:#888></span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>at_x: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>T</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#bbb> </span><span style=color:#333>*</span>at_x;<span style=color:#bbb>
</span><span style=display:block;width:100%;background-color:#e5e5e5><span style=color:#bbb>    </span><span style=color:#888>// now, let&#39;s upgrade it back:
</span></span><span style=color:#888></span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>at_x: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>mut</span><span style=color:#bbb> </span>T<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>unsafe</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span>core::mem::transmute::<span style=color:#333>&lt;&amp;</span>T,<span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>T<span style=color:#333>&gt;</span>(at_x)<span style=color:#bbb>
</span><span style=color:#bbb>    </span>};<span style=color:#bbb>
</span><span style=color:#bbb>    </span>core::mem::swap(at_x,<span style=color:#bbb> </span>at_y);<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>main</span><span style=color:#bbb> </span>()<span style=color:#bbb> </span>{<span style=color:#bbb> </span>swap_UB(<span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>42</span>,<span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>0</span>)<span style=color:#bbb> </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><h3 id=a-name-why-transmuting-to-mut-is-ub-a-why-transmuting-to-mut-is-ub-why-transmuting-to-mut-is-ub><a name=why-transmuting-to-mut-is-ub></a><a href=#why-transmuting-to-mut-is-ub>Why transmuting <code>&amp;</code> to <code>&amp;mut</code> is UB</a></h3><p>Because for any type <code>T</code>:</p><ol><li><p>The only<sup class=footnote-ref id=fnref:10><a href=#fn:10>10</a></sup> way to mutate a <code>T</code> is through a <strong>unique</strong> handle on that value;
<em>i.e.</em>, a straight-owned <code>T</code>, a <code>&amp;unique T</code>, a <code>&amp;unique &amp;unique T</code>, <em>etc.</em></p></li><li><p>This implies that <strong>it is not possible mutate a <code>T</code> through a <code>&amp;shared T</code> reference</strong>.</p></li><li><p>Actually, <strong>the very existence of a <code>&amp;shared T</code> reference
prevents the existence of any other <code>&amp;unique T</code> or straight-owned <code>T</code> handle that would allow us to mutate that data!!</strong></p></li><li><p>In other words, whenever a <code>&amp;shared _</code> exists, <strong>the pointee is guaranteed to be immutable
for the lifetime of the reference</strong>.</p></li><li><p>This is a very interesting invariant that the compiler can use and (<strong>does use!</strong>) to aggressively optimize your code.</p></li><li><p>So if the data turned out not to be immutable, these assumptions would be invalidated making the optimized code wrong. Such contract violation is the very definition of Undefined Behavior.</p></li></ol><h5 id=tl-dr>TL,DR</h5><blockquote><p><strong>Once a reference reaches the &ldquo;potentially shared&rdquo; state (<code>&amp;_</code>), Rust asserts that the pointee is immutable</strong> (during the lifetime of the reference).</p></blockquote><ul><li><p>Now we can see why the previous code:</p><a class=inline-svg href="https://play.rust-lang.org/?edition=2018&code=%2f%2f%21%20This%20should%20fail%0a%0a%2f%2f%21%20Run%20with%20MIRI%20to%20spot%20the%20Undefined%20Behavior%0a%0a%23%5ballow%28non_snake_case%29%5d%0afn%20swap_UB%3cT%3e%20%28at_x%3a%20%26mut%20T%2c%20at_y%3a%20%26mut%20T%29%0a%7b%0a%20%20%20%20%2f%2f%20let%20us%20temporarily%20downgrade%20our%20%60%26mut%20T%60%20into%20a%20%60%26T%60%0a%20%20%20%20let%20at_x%3a%20%26T%20%3d%20%26%20%2aat_x%3b%0a%20%20%20%20%2f%2f%20now%2c%20let%27s%20upgrade%20it%20back%3a%0a%20%20%20%20let%20at_x%3a%20%26mut%20T%20%3d%20unsafe%20%7b%0a%20%20%20%20%20%20%20%20%26mut%20%2a%28at_x%20as%20%2aconst%20T%20as%20%2amut%20T%29%0a%20%20%20%20%7d%3b%0a%20%20%20%20core%3a%3amem%3a%3aswap%28at_x%2c%20at_y%29%3b%0a%7d%0a%0afn%20main%20%28%29%20%7b%20swap_UB%28%26mut%2042%2c%20%26mut%200%29%20%7d%0a" target=_blank><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="#606060" d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937.0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154.0l239.94 416.028zM288 354c-25.405.0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346 7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373.0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884.0-12.356 5.78-11.981 12.654z"/></svg></a><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span style=color:#d42;background-color:#fff0f0>//! Run with MIRI to spot the Undefined Behavior
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span style=color:#d42;background-color:#fff0f0></span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span style=color:#bbb></span><span style=color:#579>#[allow(non_snake_case)]</span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>swap_UB</span><span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>(at_x: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>mut</span><span style=color:#bbb> </span>T,<span style=color:#bbb> </span>at_y: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>mut</span><span style=color:#bbb> </span>T)<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span style=color:#bbb>    </span><span style=color:#888>// let us temporarily downgrade our `&amp;mut T` into a `&amp;T`
</span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span style=color:#888></span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>at_x: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>T</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#bbb> </span><span style=color:#333>*</span>at_x;<span style=color:#bbb>
</span></span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span style=color:#bbb>    </span><span style=color:#888>// now, let&#39;s upgrade it back:
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span style=color:#888></span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>at_x: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>mut</span><span style=color:#bbb> </span>T<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>unsafe</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span style=color:#bbb>        </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#333>*</span>(at_x<span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#333>*</span><span style=color:#080;font-weight:700>const</span><span style=color:#bbb> </span>T<span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#333>*</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>T)<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span style=color:#bbb>    </span>};<span style=color:#bbb>
</span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span style=color:#bbb>    </span>core::mem::swap(at_x,<span style=color:#bbb> </span>at_y);<span style=color:#bbb>
</span></span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>main</span><span style=color:#bbb> </span>()<span style=color:#bbb> </span>{<span style=color:#bbb> </span>swap_UB(<span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>42</span>,<span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>0</span>)<span style=color:#bbb> </span>}<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span style=color:#bbb></span></code></pre></div><p>is Undefined Behavior; at line <code>7</code> we have created a <code>&amp;shared T</code> reference to the data pointed to by <code>at_x</code>, thus asserting to the compiler that <strong>that data is immutable for the duration of the function</strong> (the scope of the reference). And yet at line <code>12</code> that data is mutated.</p></li></ul><blockquote><p>Hmmm, isn&rsquo;t there then a way to <em>exceptionally turn down that invariant</em>?
To tell it that some data can <em>never be truly immutable</em> since it&rsquo;s kind of &hellip; <em>volatile</em> maybe?</p></blockquote><p>Ok, let&rsquo;s imagine that it can be done.</p><h1 id=hypothetical-volatile>Hypothetical <code>Volatile</code></h1><blockquote><p>How should that &ldquo;<em>volatility</em> property&rdquo; be expressed?</p></blockquote><p>Definitely not with a <code>let volatile</code> lang construct,
since that would be a binding-dependant modifier instead of a memory-dependant one (<em>c.f.</em> all that was said about <code>mut</code> bindings).</p><p>But it could be a <code>struct</code> (field) attribute:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>Foo</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#579>#[volatile]</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>bar: <span style=color:#007020>Box</span><span style=color:#333>&lt;</span><span style=color:#339;font-weight:700>i32</span><span style=color:#333>&gt;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>baz: <span style=color:#339;font-weight:700>i32</span>,<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><p>But then what would be <code>volatile</code>? The pointer, the pointee, both ?
The semantics are not clear.</p><p>The best way to express semantics is through an API, clarifying what can be done and what cannot.
Thus, let&rsquo;s use a new type pattern to encapsulate the dangerous <code>#[volatile]</code> attribute:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>Volatile</span><span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#579>#[volatile]</span><span style=color:#bbb> </span><span style=color:#888>// Attribute directly used here only!
</span><span style=color:#888></span><span style=color:#bbb>    </span>volatile_data: <span style=color:#b06;font-weight:700>T</span>,<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><p>The semantics will be the following:</p><blockquote><p><strong>The transitivity of the <em>immutability</em> property deduced from a <code>&amp;shared _</code> reference stops at a <code>Volatile&lt;_&gt;</code> wrapper boundary</strong>.</p></blockquote><p>This means that if we have:</p><ul><li><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>Person</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span>name: <span style=color:#007020>String</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span>age: <span style=color:#b06;font-weight:700>Volatile</span><span style=color:#333>&lt;</span><span style=color:#bbb> </span><span style=color:#007020>Box</span><span style=color:#333>&lt;</span><span style=color:#339;font-weight:700>i32</span><span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#333>&gt;</span>,<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>john<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>Person<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span>name: <span style=background-color:#fff0f0>&#34;Duh&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span>age: <span style=color:#b06;font-weight:700>Volatile</span><span style=color:#bbb> </span>{<span style=color:#bbb> </span>volatile_data: <span style=color:#007020>Box</span>::new(<span style=color:#00d;font-weight:700>42</span>)<span style=color:#bbb> </span>},<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div></li><li><p>and a reference <code>at_john</code> of type <code>&amp;shared Person</code></p></li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>at_john: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>Person</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span>john;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#888>// is `john` immutable ?
</span><span style=color:#888></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><p>then within the lifetime of the <code>at_john</code> reference,</p><ul><li><p><code>john.name</code> is immutable because referred by a potentially shared <code>&amp;shared</code> reference;</p></li><li><p>but <code>john.age.volatile_data</code> is not, because it&rsquo;s inside a <code>Volatile</code> wrapper (who knows, maybe <code>john</code>&rsquo;s birthday happens right within that scope and his age increments).</p></li><li><p>Note that <em>all</em> the data wrapped in a <code>Volatile</code> is considered non-immutable. So this includes both the actual age value and the pointer to the age value;</p><ul><li>However, <code>john.age</code> itself (the wrapper) is considered immutable, since the wrapper boundary has not been crossed!</li></ul></li></ul><p>This sounds exactly like what we&rsquo;d want for, for instance, concurrency (imagine another thread is busy checking whether his birthday happens to then increment his <code>age</code>).</p><p>This is all nice and pretty, but what would the actual aforementioned API be?
Having something &ldquo;volatile&rdquo; but not being actually able to mutate it sounds dumb.</p><h3 id=impl-t-volatile-t><code>impl&lt;T&gt; Volatile&lt;T&gt; {</code></h3><p>So let&rsquo;s thing about what we&rsquo;d want for <code>impl&lt;T&gt; Volatile&lt;T&gt;</code>:</p><ol><li><p>to be able to mutate its data through a <code>&amp;unique _</code> reference obviously;</p><ul><li><code>fn get_mut (self: &amp;mut Volatile&lt;T&gt;) -&gt; &amp;mut T</code></li></ul></li><li><p>but above all, we want to be able to mutate its data through a <code>&amp;shared _</code> reference:</p><ul><li><p><code>fn get (self: &amp;Volatile&lt;T&gt;) -&gt; &amp;mut T</code>?</p><p>Well, hopefully the previous line looks wrong to you too;
remember that a <code>&amp;mut T</code> means <code>&amp;unique T</code>, <em>i.e.</em>,
a valid <strong>and unique</strong> reference to the pointee.
Such output cannot<sup class=footnote-ref id=fnref:11><a href=#fn:11>11</a></sup> be guaranteed from a <code>&amp;shared</code> input!</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>at_john_1<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span>john;<span style=color:#bbb> </span><span style=color:#888>// shared, so valid
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span style=color:#888></span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>at_john_2<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span>john;<span style=color:#bbb> </span><span style=color:#888>// shared, so valid
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span style=color:#888></span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>at_age_1_mut: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>mut</span><span style=color:#bbb> </span>_<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span style=color:#bbb>    </span>Volatile::get(<span style=color:#333>&amp;</span>at_john_1.age);<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span style=color:#bbb></span><span style=color:#888>// The following line is UB
</span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span style=color:#888></span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>at_age_2_mut: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>mut</span><span style=color:#bbb> </span>_<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb>
</span></span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span style=color:#bbb>    </span>Volatile::get(<span style=color:#333>&amp;</span>at_john_2.age);<span style=color:#bbb>
</span></span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">8</span><span style=color:#bbb></span>core::mem::swap(at_age_1_mut,<span style=color:#bbb> </span>at_age_2_mut);<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">9</span><span style=color:#bbb></span></code></pre></div></li><li><p>Okay, the guarantees/semantics of a <code>&amp;unique T</code> are too strong to express
the return value of our function. We want to return a <em>raw handle to mutable data</em>,
without guaranteeing that the handle/reference is unique.</p><blockquote><p>Somebody said <em>raw handle to mutable data</em>?</p></blockquote><p>asks <code>*mut T</code> as it slams (⌐■_■) the door open;</p><p>(you may realize that <code>*mut T</code> is actually the closest thing to a &ldquo;mutable reference&rdquo;<sup class=footnote-ref id=fnref:12><a href=#fn:12>12</a></sup> in other languages. Note the difference with a <code>&amp;mut T</code>)</p></li><li><p>So, the method&rsquo;s prototype should be the following:</p><p><code>fn get (self: &amp;Volatile&lt;T&gt;) -&gt; *mut T</code></p></li></ul></li></ol><p>Let&rsquo;s try to implement it:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#080;font-weight:700>impl</span><span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>Volatile<span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>get</span><span style=color:#bbb> </span>(self: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>Self</span>)<span style=color:#bbb> </span>-&gt; <span style=color:#333>*</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>T<span style=color:#bbb>
</span><span style=color:#bbb>    </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span>(<span style=color:#333>&amp;</span>self.volatile_data)<span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#333>*</span><span style=color:#080;font-weight:700>const</span><span style=color:#bbb> </span>T<span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#333>*</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>T<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><blockquote><p>Yes, we did it!!</p></blockquote><p>Did we?</p><blockquote><p>Oh, what now!!?</p></blockquote><p>Nothing, just some&hellip;</p><p><img src=/img/this_is_fine_UB.jpg alt="Undefined Behavior"></p><blockquote><p>What!? How??</p></blockquote><p><code>&amp;self.volatile_data</code>.</p><p>After all this trouble, we just went and created (even if only for an instant)
a <code>&amp;shared _</code> to the <code>volatile_data</code>, thus asserting its immutability.</p><blockquote><p>Ok, what about the following:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#080;font-weight:700>impl</span><span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>Volatile<span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>get</span><span style=color:#bbb> </span>(self: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>Self</span>)<span style=color:#bbb> </span>-&gt; <span style=color:#333>*</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>T<span style=color:#bbb>
</span><span style=color:#bbb>    </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span>(<span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>self.volatile_data)<span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#333>*</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>T<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div></blockquote><p>This does not even compile! <code>cannot borrow as mutable, as it is behind a '&amp;' reference</code></p><blockquote><p>Ok, fixed:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>get</span><span style=color:#bbb> </span>(self: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>Self</span>)<span style=color:#bbb> </span>-&gt; <span style=color:#333>*</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>T<span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb> </span><span style=color:#080;font-weight:700>unsafe</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>(self<span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#333>*</span><span style=color:#080;font-weight:700>const</span><span style=color:#bbb> </span>Self<span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#333>*</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>Self).volatile_data<span style=color:#bbb>
</span><span style=color:#bbb></span>}}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div></blockquote><p><code>unsafe</code> is not the way to go to <em>avoid</em> UB:</p><ul><li><p>you transmuted a <code>&amp;Self</code> to a <code>*mut Self</code> which is UB if you dereference it, and
which you just did when accessing <code>volatile_data</code>;</p></li><li><p>and then you got a <code>&amp;mut volatile_data</code>, even if only for an instant, which was the problem of the very first <code>get</code>.</p></li></ul><blockquote><p>Right, right, I should have known better than to use <code>unsafe</code>.</p><p>Okay, this is my last idea:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#080;font-weight:700>impl</span><span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>Volatile<span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>get</span><span style=color:#bbb> </span>(self: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>Self</span>)<span style=color:#bbb> </span>-&gt; <span style=color:#333>*</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>T<span style=color:#bbb>
</span><span style=color:#bbb>    </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span>self<span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#333>*</span><span style=color:#080;font-weight:700>const</span><span style=color:#bbb> </span>Self<span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#333>*</span><span style=color:#080;font-weight:700>const</span><span style=color:#bbb> </span>T<span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#333>*</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>T<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><p>let me guess, UB again?</p></blockquote><p>Well, yes and no:</p><ol><li><p>it&rsquo;s UB, because you are assuming that a pointer to a <code>Volatile&lt;T&gt;</code> can be casted as
/ transmuted to a pointer to a <code>T</code>,</p><blockquote><p>Ha! I knew it!</p></blockquote></li><li><p>It&rsquo;s nevertheless the right way, since it dodged all the mutability-related UB</p><blockquote><p>Oh, I was right then?</p></blockquote></li></ol><p>Pretty much, yes. We just get rid of <code>1.</code>, by adding the <code>#[repr(transparent)]</code> attribute to
the <code>Volatile</code> wrapper:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#579>#[repr(transparent)]</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>Volatile</span><span style=color:#bbb> </span><span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#579>#[volatile]</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>volatile_data: <span style=color:#b06;font-weight:700>T</span>,<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><p><code>#[repr(transparent)]</code> guarantees that the wrapper and the wrappee(?) have exactly the same memory layout, thus making the pointer conversion <em>not</em> UB. Hooray!!</p><p>So, now we have some kind of wrapper, package, <del>box</del>, <strong>cell</strong> (you name it) that yields,
through (potentially) shared references,
<code>*mut T</code> pointers, which are <strong>unsafe</strong> to &ldquo;promote to uniqueness&rdquo; (<code>&amp;mut T</code>)</p><blockquote><p>Wait a mome&hellip;</p></blockquote><ul><li><p>Plot twist!!</p><p><strong><code>Volatile</code> was <code>UnsafeCell</code> all along!!!</strong></p><ul><li>Instead of our imagined <code>#[volatile]</code> field attribute, Rust&rsquo;s <code>core</code> uses <code>#[lang = &quot;unsafe_cell&quot;]</code> struct attribute (and they also get rid of the implicit <code>Sized</code> bound with <code>: ?Sized</code>, so as to be able to wrap DSTs with it):<div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1435</span><span style=color:#579>#[lang = </span><span style=background-color:#fff0f0>&#34;unsafe_cell&#34;</span><span style=color:#579>]</span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1436</span><span style=color:#bbb></span><span style=color:#579>#[stable(feature = </span><span style=background-color:#fff0f0>&#34;rust1&#34;</span><span style=color:#579>, since = </span><span style=background-color:#fff0f0>&#34;1.0.0&#34;</span><span style=color:#579>)]</span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1437</span><span style=color:#bbb></span><span style=color:#579>#[repr(transparent)]</span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1438</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>UnsafeCell</span><span style=color:#333>&lt;</span>T: <span style=color:#333>?</span><span style=color:#007020>Sized</span><span style=color:#333>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1439</span><span style=color:#bbb>    </span>value: <span style=color:#b06;font-weight:700>T</span>,<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1440</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1441</span><span style=color:#bbb></span></code></pre></div></li></ul></li></ul><p>Perfect, now we can talk about <em>Interior Mutability</em>, on the<div class=prev-next style=text-align:center><a class=prev-next-link href=/posts/2019-03-03-mutation-part-3-interior-mutability/><button class="button next-button">
<span>Next post</span></button></a></div></p><h1 id=appendix>Appendix</h1><h2 id=1-a-name-annotated-mir-a-annotated-mir>1 -<a name=annotated-mir></a> Annotated MIR</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>foo</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span></span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span></span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span style=color:#bbb></span><span style=color:#888>/////// LOCALS METADATA (e.g. sizes) ///////
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span style=color:#888>//      _0: ()      // return value
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span style=color:#888>//      _1: i32     // `x`
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span style=color:#888>//      _2: u8      // `y`
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span style=color:#888>//      _3: i32     // `x + 27` (before `as u8`)
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span style=color:#888>//      _4: i32     // copy of `x` (function arg)
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span style=color:#888></span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span style=color:#bbb></span><span style=color:#888>/////// let x = 42; ///////
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span style=color:#888></span><span style=color:#bbb>    </span><span style=color:#888>// let x: i32;
</span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span style=color:#888></span><span style=color:#bbb>    </span>StorageLive<span style=color:#333>!</span>(_1);<span style=color:#bbb>
</span></span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span style=color:#bbb>    </span><span style=color:#888>// x = 42;
</span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span style=color:#888></span><span style=color:#bbb>    </span>_1<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>42</span><span style=color:#080;font-weight:700>i32</span>;<span style=color:#bbb>
</span></span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span style=color:#bbb></span><span style=color:#888>/////// let y = i32::wrapping_add(x, 27); ///////
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span style=color:#888></span><span style=color:#bbb>    </span><span style=color:#888>// let y: u8;
</span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span style=color:#888></span><span style=color:#bbb>    </span>StorageLive<span style=color:#333>!</span>(_2);<span style=color:#bbb>
</span></span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span style=color:#bbb>    </span><span style=color:#888>// COMPUTE i32::wrapping_add(x, 27)
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span style=color:#888></span><span style=color:#bbb>        </span><span style=color:#888>// let _3: i32;  // (will store the result of wrapping_add)
</span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span style=color:#888></span><span style=color:#bbb>        </span>StorageLive<span style=color:#333>!</span>(_3);<span style=color:#bbb>
</span></span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span><span style=color:#bbb>        </span><span style=color:#888>// let _4: i32 = x; // (first argument of wrapping add)
</span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26</span><span style=color:#888></span><span style=color:#bbb>        </span>StorageLive<span style=color:#333>!</span>(_4);<span style=color:#bbb>
</span></span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27</span><span style=color:#bbb>        </span>_4<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>_1;<span style=color:#bbb>  </span><span style=color:#888>// read value stored at _1, and write it into _4
</span></span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28</span><span style=color:#888></span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29</span><span style=color:#bbb>        </span><span style=color:#888>// call i32::wrapping_add
</span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30</span><span style=color:#888></span><span style=color:#bbb>        </span>_3<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>i32</span>::wrapping_add(<span style=color:#080;font-weight:700>move</span><span style=color:#bbb> </span>_4,<span style=color:#bbb> </span><span style=color:#00d;font-weight:700>27</span><span style=color:#080;font-weight:700>i32</span>)<span style=color:#bbb>
</span></span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31</span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">32</span><span style=color:#bbb>        </span><span style=color:#888>// FREE ARGS
</span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">33</span><span style=color:#888></span><span style=color:#bbb>        </span>StorageDead<span style=color:#333>!</span>(_4);<span style=color:#bbb>
</span></span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">34</span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">35</span><span style=color:#bbb>    </span><span style=color:#888>// y = COMPUTE_RESULT as u8;
</span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">36</span><span style=color:#888></span><span style=color:#bbb>    </span>_2<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>_3<span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>u8</span>;<span style=color:#bbb>  </span><span style=color:#888>// read 1 byte stored at _3, and write it into _2
</span></span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">37</span><span style=color:#888></span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">38</span><span style=color:#bbb></span><span style=color:#888>/////// DROP DROP DROP ///////
</span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">39</span><span style=color:#888></span><span style=color:#bbb>    </span>StorageDead<span style=color:#333>!</span>(_3);<span style=color:#bbb>
</span></span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">40</span><span style=color:#bbb>    </span>StorageDead<span style=color:#333>!</span>(_2);<span style=color:#bbb>
</span></span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">41</span><span style=color:#bbb>    </span>StorageDead<span style=color:#333>!</span>(_1);<span style=color:#bbb>
</span></span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">42</span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">43</span><span style=color:#bbb></span><span style=color:#888>/////// END =&gt; RETURN ///////
</span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">44</span><span style=color:#888></span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>return</span>;<span style=color:#bbb>
</span></span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">45</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">46</span><span style=color:#bbb></span></code></pre></div><h2 id=2-a-name-data-rodata-a-readonly-vs-writeable-static-s>2 -<a name=data-rodata></a>readonly vs writeable <code>static</code>s</h2><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#080;font-weight:700>use</span><span style=color:#bbb> </span>::std::sync::atomic::AtomicIsize;<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#d42;background-color:#fff0f0>/// neither `mut` nor interior mutability =&gt; .rodata (R)
</span><span style=color:#d42;background-color:#fff0f0></span><span style=color:#579>#[no_mangle]</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>static</span><span style=color:#bbb>      </span>W: <span style=color:#339;font-weight:700>isize</span> <span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>42</span>;<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#d42;background-color:#fff0f0>/// `mut` =&gt; .data (D)
</span><span style=color:#d42;background-color:#fff0f0></span><span style=color:#579>#[no_mangle]</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>static</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb>  </span>X: <span style=color:#339;font-weight:700>isize</span> <span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>421</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#d42;background-color:#fff0f0>/// interior mutability =&gt; .data (D)
</span><span style=color:#d42;background-color:#fff0f0></span><span style=color:#579>#[no_mangle]</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>static</span><span style=color:#bbb>      </span>Y: <span style=color:#b06;font-weight:700>AtomicIsize</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>AtomicIsize::new(<span style=color:#00d;font-weight:700>42</span>);<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#d42;background-color:#fff0f0>/// mutable &amp; 0-init =&gt; .bss (B)
</span><span style=color:#d42;background-color:#fff0f0></span><span style=color:#579>#[no_mangle]</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>static</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>Zero: <span style=color:#339;font-weight:700>isize</span> <span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>0</span>;<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></td></tr></table></div></div><h4 id=proof>Proof</h4><p><asciinema-player src=/casts/data-rodata.cast cols=640 rows=20 start-at=0 speed=1.5 idle-time-limit=0.3 font-size=16></asciinema-player></p><h2 id=3-a-name-mut-const-a-transmuting-int-const-to-int-in-c>3 -<a name=mut-const></a> Transmuting <code>int const *</code> to <code>int *</code> in C:</h2><p><asciinema-player src=/casts/const-mut.cast cols=640 rows=10 start-at=0 speed=1.5 idle-time-limit=0.3 font-size=16></asciinema-player></p><div class=footnotes><hr><ol><li id=fn:1>although the compiler can &ldquo;memoize&rdquo; memory reads by reusing registers.
<a class=footnote-return href=#fnref:1><sup>[return]</sup></a></li><li id=fn:2>see the <a href=#annotated-mir>annotated MIR</a>
<a class=footnote-return href=#fnref:2><sup>[return]</sup></a></li><li id=fn:3>try running the above code with MIRI
<a class=footnote-return href=#fnref:3><sup>[return]</sup></a></li><li id=fn:4>except for a <code>static</code> with an <a href=https://doc.rust-lang.org/core/cell/struct.UnsafeCell.html><code>UnsafeCell</code></a> in it
<a class=footnote-return href=#fnref:4><sup>[return]</sup></a></li><li id=fn:5>that &ldquo;other&rdquo; variable could perfectly have had the same name as the initial var, shadowing it
<a class=footnote-return href=#fnref:5><sup>[return]</sup></a></li><li id=fn:6>thus being backed by at least <code>log</code><sub><code>2</code></sub><code>(2) = 1</code> bit, which makes mutation observable.
<a class=footnote-return href=#fnref:6><sup>[return]</sup></a></li><li id=fn:7>while a unique reference to some thing is in scope, the compiler statically <code>Freeze</code>s that &ldquo;thing&rdquo; to ensure uniqueness
<a class=footnote-return href=#fnref:7><sup>[return]</sup></a></li><li id=fn:8>I really wanted to use the word &lsquo;unique&rsquo;, here :P
<a class=footnote-return href=#fnref:8><sup>[return]</sup></a></li><li id=fn:9>Which should really make everybody question their ability to write safe <code>unsafe</code> code&hellip;
<a class=footnote-return href=#fnref:9><sup>[return]</sup></a></li><li id=fn:10>Except for anything wrapped within an <code>UnsafeCell</code>, as will be discussed afterwards
<a class=footnote-return href=#fnref:10><sup>[return]</sup></a></li><li id=fn:11>Unless, of course, runtime checks are integrated, but that is not the role of a raw low-level API
<a class=footnote-return href=#fnref:11><sup>[return]</sup></a></li><li id=fn:12>Having to use <code>*mut T</code> to talk about a mutable <em>valid</em> handle to data of type <code>T</code> is a little bit sad, since <code>*mut T</code> is a type describing pointers that can also be <code>NULL</code> or dangling; thus the returned <code>*mut T</code> in our case does not benefit from optimizations guarantees that could take place based on the fact our returned pointer is valid and (thus) non-null.
<a class=footnote-return href=#fnref:12><sup>[return]</sup></a></li></ol></div><script src=https://danielhenrymantilla.github.io/js/asciinema-player.js></script></div><div class=prev-next><a class="prev-next-link prev-link" href=/posts/2019-02-19-mutation-part-1-variables/><button class="button prev-button">
<span>Prev post</span></button></a>
<a class="prev-next-link next-link" href=/posts/2019-03-03-mutation-part-3-interior-mutability/><button class="button next-button">
<span>Next post</span></button></a></div></main></body></html>