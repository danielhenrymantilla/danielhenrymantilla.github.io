<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=//gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.49.2"><meta name=viewport content="width=device-width,initial-scale=1"><title>Mutation - part 3: Aliased Mutability &middot; Another one bytes the Rust!</title><link type=text/css rel=stylesheet href=https://danielhenrymantilla.github.io/css/prev-next_buttons.css><link type=text/css rel=stylesheet href=https://danielhenrymantilla.github.io/css/inline_svgs.css><link type=text/css rel=stylesheet href=https://danielhenrymantilla.github.io/css/print.css media=print><link type=text/css rel=stylesheet href=https://danielhenrymantilla.github.io/css/poole.css><link type=text/css rel=stylesheet href=https://danielhenrymantilla.github.io/css/syntax.css><link type=text/css rel=stylesheet href=https://danielhenrymantilla.github.io/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><link href rel=alternate type=application/rss+xml title="Another one bytes the Rust!"></head><body class="theme-base-08 layout-reverse"><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://danielhenrymantilla.github.io/><h1>Another one bytes the Rust!</h1></a><p class=lead>Thoughts and ramblings for the like-minded</p></div><nav><ul class=sidebar-nav><li><a href=https://danielhenrymantilla.github.io/>Home</a></li><li><a href=/series>Blog Post Series</a></li><li><a href=/categories>Categories</a></li><li><a href=/tags>Tags</a></li></ul></nav><p>&copy; 2019. All rights reserved.</p></div></aside><main class="content container"><div class=prev-next><a class="prev-next-link prev-link" href=/posts/2019-02-24-mutation-part-2-to-mut-or-not-to-mut/><button class="button prev-button">
<span>Prev post</span></button></a></div><div class=post><h1>Mutation - part 3: Aliased Mutability</h1><time datetime=2019-03-03T23:28:36&#43;0100 class=post-date>Sun, Mar 3, 2019</time><h1 style=display:none>Interior Mutability</h1><h2 id=aliased-data>Aliased data</h2><p>We say that data is aliased / shared when it may be accessed
from multiple variables or places:</p><ul><li><p>a <strong><code>static</code> variable</strong> can be accessed from anywhere<sup class=footnote-ref id=fnref:1><a href=#fn:1>1</a></sup> at anytime,
and is thus always considered <em>shared</em>.</p></li><li><p>a <strong>variable being borrowed with a <code>&amp; _</code> reference</strong>
(hence my calling these references <code>&amp;shared _</code>).</p></li><li><p>a <strong>variable owned by a smart pointer offering <em>Shared Ownership</em></strong> such
as <code>Rc</code> or <code>Arc</code>.</p></li></ul><p>Aliasing can be necessary, for instance, when sharing data across threads.
Imagine, for instance, that you have a big <code>String</code> that you want to read
from across two places (in this case, two different threads), and you don&rsquo;t
want to needlessly copy it. The solution? You borrow it twice by creating
two <code>&amp;shared String</code> references out of it, and then proceed to <code>move</code> each
one to each thread.</p><ul><li>Note: Instead of <code>&amp;'_ String</code>, <code>Arc&lt;str&gt;</code> would also work, and it would be
<code>'static</code>, thus working even with <code>::std::thread::spawn()</code>.</li></ul><a class=inline-svg href="https://play.rust-lang.org/?edition=2018&code=use%20%3a%3astd%3a%3a%7bthread%2c%20time%3a%3aDuration%7d%3b%0ause%20%3a%3acrossbeam%3a%3athread%3a%3ascope%3b%0a%0afn%20main%20%28%29%0a%7b%0a%20%20%20%20let%20big_string%3a%20String%20%3d%20%22SPAM%22.repeat%281_000%29%3b%0a%20%20%20%20let%20ref_1%3a%20%26%2f%2ashared%2a%2f%20String%20%3d%20%26big_string%3b%0a%20%20%20%20let%20ref_2%3a%20%26%2f%2ashared%2a%2f%20String%20%3d%20%26big_string%3b%0a%0a%20%20%20%20scope%28move%20%2f%2a%20ref_1%20and%20ref_2%20%2a%2f%20%7cscope%7c%20%7b%0a%20%20%20%20%20%20%20%20%2f%2f%20Thread1%0a%20%20%20%20%20%20%20%20scope.spawn%28move%20%2f%2a%20ref_1%20%2a%2f%20%7c_%7c%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20read_string%28ref_1%29%3b%0a%20%20%20%20%20%20%20%20%7d%29%3b%0a%20%20%20%20%20%20%20%20%2f%2f%20Thread2%0a%20%20%20%20%20%20%20%20scope.spawn%28move%20%2f%2a%20ref_2%20%2a%2f%20%7c_%7c%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20read_string%28ref_2%29%3b%0a%20%20%20%20%20%20%20%20%7d%29%3b%0a%20%20%20%20%7d%29%20%20%2f%2f%20automagically%20joins%20all%20the%20scoped%20threads%0a%20%20%20%20%20%20%20%20.expect%28%22Some%20thread%20panicked%22%29%3b%0a%7d%0a%0afn%20read_string%20%28s%3a%20%26%2f%2a%20shared%20%2a%2f%20String%29%0a%7b%0a%20%20%20%20let%20thread_id%20%3d%20thread%3a%3acurrent%28%29.id%28%29%3b%0a%20%20%20%20println%21%28%0a%20%20%20%20%20%20%20%20%22%5b%7b%3a%3f%7d%5d%20Reading%20s%20%3d%20%7b%3a%3f%7d%22%2c%0a%20%20%20%20%20%20%20%20thread_id%2c%0a%20%20%20%20%20%20%20%20%2as%2c%20%2f%2f%20read%20the%20string%20data%0a%20%20%20%20%29%3b%0a%7d%0a" target=_blank><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="#606060" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span style=color:#080;font-weight:700>use</span><span style=color:#bbb> </span>::std::{thread,<span style=color:#bbb> </span>time::Duration};<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>use</span><span style=color:#bbb> </span>::crossbeam::thread::scope;<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>main</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>big_string: <span style=color:#007020>String</span> <span style=color:#333>=</span><span style=color:#bbb> </span><span style=background-color:#fff0f0>&#34;SPAM&#34;</span>.repeat(<span style=color:#00d;font-weight:700>1_000</span>);<span style=color:#bbb>
</span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>ref_1: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#888>/*shared*/</span><span style=color:#bbb> </span><span style=color:#007020>String</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span>big_string;<span style=color:#bbb>
</span></span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>ref_2: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#888>/*shared*/</span><span style=color:#bbb> </span><span style=color:#007020>String</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span>big_string;<span style=color:#bbb>
</span></span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span style=color:#bbb>    </span>scope(<span style=color:#080;font-weight:700>move</span><span style=color:#bbb> </span><span style=color:#888>/* ref_1 and ref_2 */</span><span style=color:#bbb> </span><span style=color:#333>|</span>scope<span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span style=color:#bbb>        </span><span style=color:#888>// Thread1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span style=color:#888></span><span style=color:#bbb>        </span>scope.spawn(<span style=color:#080;font-weight:700>move</span><span style=color:#bbb> </span><span style=color:#888>/* ref_1 */</span><span style=color:#bbb> </span><span style=color:#333>|</span>_<span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span style=color:#bbb>            </span>read_string(ref_1);<span style=color:#bbb>
</span></span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span style=color:#bbb>        </span>});<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span style=color:#bbb>        </span><span style=color:#888>// Thread2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span style=color:#888></span><span style=color:#bbb>        </span>scope.spawn(<span style=color:#080;font-weight:700>move</span><span style=color:#bbb> </span><span style=color:#888>/* ref_2 */</span><span style=color:#bbb> </span><span style=color:#333>|</span>_<span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=display:block;width:100%;background-color:#e5e5e5><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span style=color:#bbb>            </span>read_string(ref_2);<span style=color:#bbb>
</span></span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span style=color:#bbb>        </span>});<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span style=color:#bbb>    </span>})<span style=color:#bbb>  </span><span style=color:#888>// automagically joins all the scoped threads
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span style=color:#888></span><span style=color:#bbb>        </span>.expect(<span style=background-color:#fff0f0>&#34;Some thread panicked&#34;</span>);<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>read_string</span><span style=color:#bbb> </span>(s: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#888>/* shared */</span><span style=color:#bbb> </span><span style=color:#007020>String</span>)<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>thread_id<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>thread::current().id();<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26</span><span style=color:#bbb>    </span>println<span style=color:#333>!</span>(<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27</span><span style=color:#bbb>        </span><span style=background-color:#fff0f0>&#34;[{:?}] Reading s = {:?}&#34;</span>,<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28</span><span style=color:#bbb>        </span>thread_id,<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29</span><span style=color:#bbb>        </span><span style=color:#333>*</span>s,<span style=color:#bbb> </span><span style=color:#888>// read the string data
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30</span><span style=color:#888></span><span style=color:#bbb>    </span>);<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">32</span><span style=color:#bbb></span></code></pre></div><p>As you can see, Rust does not complain, even though, at the highlighted lines, <code>big_string</code> is borrowed twice <strong>in an overlapping (aliasing) manner</strong>: for their virtue of being <em>shared</em>, shared references can overlap and be copied (<code>&amp;T : Copy</code>).</p><p>This is the closest thing to most non-Rust programmers&rsquo; intuition about pointers:
as long as the pointee exists and does not move, we can have as many pointers to the pointee as we wish.</p><blockquote><p>What has <em>mutation</em> to do with all this?</p></blockquote><p>Well, in most programming languages, we are allowed to mutate the pointee even when there are multiple pointers pointing to the same pointee!
(the only thing forbidden being to simultaneously read and write a value: a data race).</p><p>Take, for instance, the following C code:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#579>#include</span> <span style=color:#579>&lt;stdio.h&gt;</span><span style=color:#579>
</span><span style=color:#579></span>
<span style=color:#888>// Perfectly valid C code.
</span><span style=color:#888></span><span style=color:#339;font-weight:700>int</span> <span style=color:#06b;font-weight:700>main</span> (<span style=color:#339;font-weight:700>void</span>)
{
    <span style=color:#339;font-weight:700>int</span> x <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>42</span>;
    <span style=color:#339;font-weight:700>int</span> <span style=color:#333>*</span> p1 <span style=color:#333>=</span> <span style=color:#333>&amp;</span>x;
    <span style=color:#339;font-weight:700>int</span> <span style=color:#333>*</span> p2 <span style=color:#333>=</span> <span style=color:#333>&amp;</span>x;
    <span style=color:#333>*</span>p2 <span style=color:#333>=</span> <span style=color:#333>*</span>p2 <span style=color:#333>+</span> <span style=color:#00d;font-weight:700>27</span>;
    printf(<span style=background-color:#fff0f0>&#34;x = %d</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>, <span style=color:#333>*</span>p1);
    <span style=color:#080;font-weight:700>return</span> <span style=color:#00d;font-weight:700>0</span>;
}</code></pre></div><p>As you can see, in a language such as C, it is perfectly valid to:</p><ol><li><p>have <em>multiple mutable references aliasing the same thing</em>,</p></li><li><p>use one of the references (here, <code>p2</code>) to mutate the pointee,</p></li><li><p>and use the other reference (<code>p1</code>).</p></li></ol><hr><p>This example will suffice to prove that:</p><blockquote><p><strong><code>&amp;mut _</code> does not correspond to what most programmers mean by &ldquo;mutable reference&rdquo;</strong></p></blockquote><p>Indeed, if it were the case, then we should be able to rewrite the C code
(which &ndash;let me remind you&ndash; is correct and valid) in Rust in the following
fashion:</p><a class=inline-svg href="https://play.rust-lang.org/?edition=2018&code=%2f%2f%21%20This%20should%20fail%0a%0a%23%5ballow%28non_camel_case_types%29%5d%0atype%20int%20%3d%20i32%3b%0a%0afn%20main%20%28%29%0a%7b%0a%20%20%20%20let%20mut%20x%3a%20int%20%3d%2042%3b%0a%20%20%20%20let%20p1%3a%20%26mut%20int%20%3d%20%26mut%20x%3b%0a%20%20%20%20let%20p2%3a%20%26mut%20int%20%3d%20%26mut%20x%3b%0a%20%20%20%20%2ap2%20%3d%20%2ap2%20%2b%2027%3b%0a%20%20%20%20println%21%28%22x%20%3d%20%7b%7d%22%2c%20%2ap1%29%3b%0a%7d%0a" target=_blank><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="#606060" d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937.0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154.0l239.94 416.028zM288 354c-25.405.0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346 7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373.0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884.0-12.356 5.78-11.981 12.654z"/></svg></a><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#579>#[allow(non_camel_case_types)]</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>type</span> <span style=color:#b06;font-weight:700>int</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>i32</span>;<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>main</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>x: <span style=color:#b06;font-weight:700>int</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>42</span>;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>p1: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>mut</span><span style=color:#bbb> </span>int<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>x;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>p2: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>mut</span><span style=color:#bbb> </span>int<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>x;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#333>*</span>p2<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>*</span>p2<span style=color:#bbb> </span><span style=color:#333>+</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>27</span>;<span style=color:#bbb>
</span><span style=color:#bbb>    </span>println<span style=color:#333>!</span>(<span style=background-color:#fff0f0>&#34;x = {}&#34;</span>,<span style=color:#bbb> </span><span style=color:#333>*</span>p1);<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><p>And yet such code fails to compile, because, as said in the previous part,
<code>&amp;mut</code> is the type of <strong>unique</strong> references, and since <code>p1</code> and <code>p2</code> overlap,
claiming that they are the unique holder of the address of <code>x</code> is a lie
that Rust spots easily.</p><ul><li>Obviously, changing <code>p1</code> to be a <em>shared</em> reference does not suffice to
soothe Rust, since <code>p2</code> is still claiming to be unique.</li></ul><h4 id=can-we-rewrite-it-in-rust>Can we rewrite it in Rust?</h4><p>So, since C code can always be rewritten with (<code>unsafe</code>) Rust,
we may then think that expressing &ldquo;<code>p1</code> is not being used while <code>x</code> is
mutated through <code>p2</code>&rdquo; needs raw pointers:</p><a class=inline-svg href="https://play.rust-lang.org/?edition=2018&code=%23%5ballow%28non_camel_case_types%29%5d%0atype%20int%20%3d%20i32%3b%0a%0afn%20main%20%28%29%0a%7b%0a%20%20%20%20let%20mut%20x%3a%20int%20%3d%2042%3b%0a%20%20%20%20let%20p1%3a%20%2amut%20int%20%3d%20%26mut%20x%3b%0a%20%20%20%20let%20p2%3a%20%26mut%20int%20%3d%20%26mut%20x%3b%0a%20%20%20%20%2ap2%20%3d%20%2ap2%20%2b%2027%3b%0a%20%20%20%20println%21%28%22x%20%3d%20%7b%7d%22%2c%20unsafe%20%7b%20%2ap1%20%7d%29%3b%0a%7d%0a" target=_blank><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="#606060" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#579>#[allow(non_camel_case_types)]</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>type</span> <span style=color:#b06;font-weight:700>int</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>i32</span>;<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>main</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>x: <span style=color:#b06;font-weight:700>int</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>42</span>;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>p1: <span style=color:#333>*</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>int<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>x;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>p2: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>mut</span><span style=color:#bbb> </span>int<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>x;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#333>*</span>p2<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>*</span>p2<span style=color:#bbb> </span><span style=color:#333>+</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>27</span>;<span style=color:#bbb>
</span><span style=color:#bbb>    </span>println<span style=color:#333>!</span>(<span style=background-color:#fff0f0>&#34;x = {}&#34;</span>,<span style=color:#bbb> </span><span style=color:#080;font-weight:700>unsafe</span><span style=color:#bbb> </span>{<span style=color:#bbb> </span><span style=color:#333>*</span>p1<span style=color:#bbb> </span>});<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><p>The above program compiles without any warning whatsoever, so everything is
fine with this Brave New Idiom. Hooray!</p><p>This definitely deserves a good cup of coffee.</p><p>Let&rsquo;s take our sweet time to drink it.</p><p><img src=/img/this_is_fine_UB.jpg alt="Cup of Undefined Behavior Coffee"></p><ul><li>(the skeptical reader may run the code with Miri to be convinced)</li></ul><p>Yep. I said that the unicity property was a false claim and a lie,
and instead of fixing it, we just decided to go and lie in a more insidious
way, abusing Rust&rsquo;s <code>unsafe</code> trust.</p><p>To see why this is UB, there is something that even most Rust programmers are
not aware of:</p><blockquote><p>Between the time a reference / pointer is created
and the last time it is used, <strong>there is no difference, aliasing-wise, between
a borrowing reference and a raw pointer</strong><sup class=footnote-ref id=fnref:2><a href=#fn:2>2</a></sup>.</p></blockquote><ul><li><p>The only time where &ldquo;downgrading&rdquo; a Rust reference to a raw pointer
can be useful is when dealing with lifetimes / more complex memory
properties:</p><a class=inline-svg href="https://play.rust-lang.org/?edition=2018&code=%2f%2f%21%20This%20should%20fail%0a%0afn%20main%20%28%29%0a%7b%0a%20%20%20%20let%20p1%3a%20Box%3ci32%3e%20%3d%20Box%3a%3anew%2842%29%3b%0a%20%20%20%20let%20at_ft%3a%20%26i32%20%3d%20%26%2ap1%3b%0a%20%20%20%20let%20p2%20%3d%20p1%3b%20%2f%2f%20move%20the%20pointer%20but%20not%20the%20pointee%0a%20%20%20%20println%21%28%22%7b%7d%22%2c%20%2aat_ft%29%3b%0a%7d%0a" target=_blank><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="#606060" d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937.0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154.0l239.94 416.028zM288 354c-25.405.0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346 7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373.0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884.0-12.356 5.78-11.981 12.654z"/></svg></a><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>main</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>p1: <span style=color:#007020>Box</span><span style=color:#333>&lt;</span><span style=color:#339;font-weight:700>i32</span><span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#007020>Box</span>::new(<span style=color:#00d;font-weight:700>42</span>);<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>at_ft: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#339;font-weight:700>i32</span> <span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>&amp;*</span>p1;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>p2<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>p1;<span style=color:#bbb> </span><span style=color:#888>// move the pointer but not the pointee
</span><span style=color:#888></span><span style=color:#bbb>    </span>println<span style=color:#333>!</span>(<span style=background-color:#fff0f0>&#34;{}&#34;</span>,<span style=color:#bbb> </span><span style=color:#333>*</span>at_ft);<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><p>The above code fails to compile even though <code>at_ft</code> is still a valid pointer.
But Rust analysis conservatively assumes that whenever a variable is moved,
all the values borrowed through it may also have moved, thus invalidating
all the borrows.
This prevents us from accidentally using <code>&amp;p1: &amp;Box&lt;i32&gt;</code> after <code>p1</code> is moved,
but it also prevents us from using <code>at_ft</code>, since Rust cannot tell the difference
(both <code>&amp;p1</code> and <code>at_ft = &amp;*p1</code> borrow from <code>p1</code>).</p><p>This is a case where <code>unsafe</code> and raw pointers are legitimate:</p><pre><code><a class=inline-svg href="https://play.rust-lang.org/?edition=2018&version=nightly&code=%23%21%5bfeature%28box_into_raw_non_null%29%5d%0ause%20%3a%3astd%3a%3aptr%3b%0a%0afn%20main%20%28%29%0a%7b%0a%20%20%20%20let%20p1%3a%20Box%3ci32%3e%20%3d%20Box%3a%3anew%2842%29%3b%0a%20%20%20%20%2f%2f%20a%20boxed%20element%20cannot%20be%20aliased%2c%0a%20%20%20%20%2f%2f%20so%20let%27s%20use%20NonNull%20for%20less%20strict%20semantics.%0a%20%20%20%20let%20p1%3a%20ptr%3a%3aNonNull%3ci32%3e%20%3d%0a%20%20%20%20%20%20%20%20Box%3a%3ainto_raw_non_null%28p1%29%0a%20%20%20%20%3b%0a%20%20%20%20let%20at_ft%3a%20%2aconst%20i32%20%3d%20p1.as_ptr%28%29%3b%0a%20%20%20%20let%20p2%20%3d%20p1%3b%20%2f%2f%20move%20the%20pointer%20but%20not%20the%20pointee%0a%20%20%20%20unsafe%20%7b%0a%20%20%20%20%20%20%20%20println%21%28%22%7b%7d%22%2c%20%2aat_ft%29%3b%0a%20%20%20%20%20%20%20%20let%20_%3a%20Box%3ci32%3e%20%3d%20Box%3a%3afrom_raw%28p2.as_ptr%28%29%29%3b%0a%20%20%20%20%7d%0a%7d%0a" target=_blank><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="#606060" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#579>#![feature(box_into_raw_non_null)]</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>use</span><span style=color:#bbb> </span>::std::ptr;<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>main</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>p1: <span style=color:#007020>Box</span><span style=color:#333>&lt;</span><span style=color:#339;font-weight:700>i32</span><span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#007020>Box</span>::new(<span style=color:#00d;font-weight:700>42</span>);<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#888>// a boxed element cannot be aliased,
</span><span style=color:#888></span><span style=color:#bbb>    </span><span style=color:#888>// so let&#39;s use NonNull for less strict semantics.
</span><span style=color:#888></span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>p1: <span style=color:#b06;font-weight:700>ptr</span>::NonNull<span style=color:#333>&lt;</span><span style=color:#339;font-weight:700>i32</span><span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#007020>Box</span>::into_raw_non_null(p1)<span style=color:#bbb>
</span><span style=color:#bbb>    </span>;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>at_ft: <span style=color:#333>*</span><span style=color:#080;font-weight:700>const</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>i32</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>p1.as_ptr();<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>p2<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>p1;<span style=color:#bbb> </span><span style=color:#888>// move the pointer but not the pointee
</span><span style=color:#888></span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>unsafe</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span>println<span style=color:#333>!</span>(<span style=background-color:#fff0f0>&#34;{}&#34;</span>,<span style=color:#bbb> </span><span style=color:#333>*</span>at_ft);<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>_: <span style=color:#007020>Box</span><span style=color:#333>&lt;</span><span style=color:#339;font-weight:700>i32</span><span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#007020>Box</span>::from_raw(p2.as_ptr());<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div></code></pre></li></ul><hr><p>So, back to the problem of expressing aliased mutation in Rust,</p><blockquote><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#339;font-weight:700>int</span> x <span style=color:#333>=</span> <span style=color:#00d;font-weight:700>42</span>;
<span style=color:#339;font-weight:700>int</span> <span style=color:#333>*</span> p1 <span style=color:#333>=</span> <span style=color:#333>&amp;</span>x;
<span style=color:#339;font-weight:700>int</span> <span style=color:#333>*</span> p2 <span style=color:#333>=</span> <span style=color:#333>&amp;</span>x;
<span style=color:#333>*</span>p2 <span style=color:#333>=</span> <span style=color:#333>*</span>p2 <span style=color:#333>+</span> <span style=color:#00d;font-weight:700>27</span>;
printf(<span style=background-color:#fff0f0>&#34;x = %d</span><span style=color:#666;background-color:#fff0f0;font-weight:700>\n</span><span style=background-color:#fff0f0>&#34;</span>, <span style=color:#333>*</span>p1);</code></pre></div></blockquote><p>what is the answer?</p><p>For that, we need to think about our situation:</p><blockquote><p>we need to mutate something through a reference that <del>may be</del> is aliased,
and we know this is valid because for the duration of the mutation
(through <code>p2</code>), we know that the other pointer / reference, <code>p1</code>,
is not being dereferenced, so no data race is possible.</p></blockquote><p>This is exactly what <code>UnsafeCell</code> is for!</p><a class=inline-svg href="https://play.rust-lang.org/?edition=2018&code=use%20%3a%3acore%3a%3acell%3a%3aUnsafeCell%3b%0a%0a%23%5ballow%28non_camel_case_types%29%5d%0atype%20int%20%3d%20i32%3b%0a%0afn%20main%20%28%29%0a%7b%0a%20%20%20%20let%20x%3a%20UnsafeCell%3cint%3e%20%3d%20UnsafeCell%3a%3anew%2842%29%3b%0a%20%20%20%20let%20p1%3a%20%26UnsafeCell%3cint%3e%20%3d%20%26x%3b%0a%20%20%20%20let%20p2%3a%20%26UnsafeCell%3cint%3e%20%3d%20%26x%3b%0a%20%20%20%20unsafe%20%7b%0a%20%20%20%20%20%20%20%20%2ap2.get%28%29%20%3d%20%2ap2.get%28%29%20%2b%2027%3b%0a%20%20%20%20%20%20%20%20println%21%28%22x%20%3d%20%7b%7d%22%2c%20%2ap1.get%28%29%29%3b%0a%20%20%20%20%7d%0a%7d%0a" target=_blank><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="#606060" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#080;font-weight:700>use</span><span style=color:#bbb> </span>::core::cell::UnsafeCell;<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#579>#[allow(non_camel_case_types)]</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>type</span> <span style=color:#b06;font-weight:700>int</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>i32</span>;<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>main</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>x: <span style=color:#b06;font-weight:700>UnsafeCell</span><span style=color:#333>&lt;</span>int<span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>UnsafeCell::new(<span style=color:#00d;font-weight:700>42</span>);<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>p1: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>UnsafeCell</span><span style=color:#333>&lt;</span>int<span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span>x;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>p2: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>UnsafeCell</span><span style=color:#333>&lt;</span>int<span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span>x;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>unsafe</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#333>*</span>p2.get()<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>*</span>p2.get()<span style=color:#bbb> </span><span style=color:#333>+</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>27</span>;<span style=color:#bbb>
</span><span style=color:#bbb>        </span>println<span style=color:#333>!</span>(<span style=background-color:#fff0f0>&#34;x = {}&#34;</span>,<span style=color:#bbb> </span><span style=color:#333>*</span>p1.get());<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><p>To better understand this code, let&rsquo;s rename <code>UnsafeCell</code> to <code>Mut</code>,
and explicit when the dereference (<code>*_.get()</code>) is used to read and write:</p><ul><li>(with <code>UnsafeCell</code> being named Mut, it will be easier to get the mental model
of <code>&amp;UnsafeCell&lt;T&gt;</code> being lile <code>&amp;Mut&lt;T&gt;</code>)</li></ul><a class=inline-svg href="https://play.rust-lang.org/?edition=2018&code=%23%5ballow%28non_camel_case_types%29%5d%0atype%20int%20%3d%20i32%3b%0a%0afn%20main%20%28%29%0a%7b%0a%20%20%20%20use%20lib%3a%3aMut%3b%0a%20%20%20%20let%20x%3a%20Mut%3cint%3e%20%3d%20Mut%3a%3anew%2842%29%3b%0a%20%20%20%20let%20p1%3a%20%26Mut%3cint%3e%20%3d%20%26x%3b%0a%20%20%20%20let%20p2%3a%20%26Mut%3cint%3e%20%3d%20%26x%3b%0a%20%20%20%20unsafe%20%7b%0a%20%20%20%20%20%20%20%20p2.set%28p2.get%28%29%20%2b%2027%29%3b%0a%20%20%20%20%20%20%20%20println%21%28%22x%20%3d%20%7b%7d%22%2c%20p1.get%28%29%29%3b%0a%20%20%20%20%7d%0a%7d%0a%0a%2f%2f%2f%20Mut%20implementation%0amod%20lib%20%7b%0a%20%20%20%20use%20%3a%3acore%3a%3a%7bcell%3a%3aUnsafeCell%2c%20ptr%7d%3b%0a%0a%20%20%20%20pub%0a%20%20%20%20struct%20Mut%3cT%3e%20%2f%2a%20%3d%20%2a%2f%20%28%0a%20%20%20%20%20%20%20%20UnsafeCell%3cT%3e%2c%0a%20%20%20%20%29%3b%0a%0a%20%20%20%20impl%3cT%3e%20Mut%3cT%3e%20%7b%0a%20%20%20%20%20%20%20%20pub%0a%20%20%20%20%20%20%20%20fn%20new%20%28value%3a%20T%29%20-%3e%20Self%0a%20%20%20%20%20%20%20%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20Self%28UnsafeCell%3a%3anew%28value%29%29%0a%20%20%20%20%20%20%20%20%7d%0a%0a%20%20%20%20%20%20%20%20pub%0a%20%20%20%20%20%20%20%20unsafe%0a%20%20%20%20%20%20%20%20fn%20get%20%28self%3a%20%26%27_%20Self%29%20-%3e%20T%0a%20%20%20%20%20%20%20%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20ptr%3a%3aread%28self.0.get%28%29%29%0a%20%20%20%20%20%20%20%20%7d%0a%0a%20%20%20%20%20%20%20%20%2f%2f%2f%20Look%2c%20mutation%20through%20a%20shared%20reference%0a%20%20%20%20%20%20%20%20pub%0a%20%20%20%20%20%20%20%20unsafe%0a%20%20%20%20%20%20%20%20fn%20set%20%28self%3a%20%26%27_%20Self%2c%20value%3a%20T%29%0a%20%20%20%20%20%20%20%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20ptr%3a%3awrite%28self.0.get%28%29%2c%20value%29%3b%0a%20%20%20%20%20%20%20%20%7d%0a%20%20%20%20%7d%0a%7d%0a" target=_blank><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="#606060" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#579>#[allow(non_camel_case_types)]</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>type</span> <span style=color:#b06;font-weight:700>int</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>i32</span>;<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>main</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>use</span><span style=color:#bbb> </span>lib::Mut;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>x: <span style=color:#b06;font-weight:700>Mut</span><span style=color:#333>&lt;</span>int<span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>Mut::new(<span style=color:#00d;font-weight:700>42</span>);<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>p1: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>Mut</span><span style=color:#333>&lt;</span>int<span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span>x;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>p2: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>Mut</span><span style=color:#333>&lt;</span>int<span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span>x;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>unsafe</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span>p2.set(p2.get()<span style=color:#bbb> </span><span style=color:#333>+</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>27</span>);<span style=color:#bbb>
</span><span style=color:#bbb>        </span>println<span style=color:#333>!</span>(<span style=background-color:#fff0f0>&#34;x = {}&#34;</span>,<span style=color:#bbb> </span>p1.get());<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#d42;background-color:#fff0f0>/// Mut implementation
</span><span style=color:#d42;background-color:#fff0f0></span><span style=color:#080;font-weight:700>mod</span> <span style=color:#0e84b5;font-weight:700>lib</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>use</span><span style=color:#bbb> </span>::core::{cell::UnsafeCell,<span style=color:#bbb> </span>ptr};<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>Mut</span><span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#888>/* = */</span><span style=color:#bbb> </span>(<span style=color:#bbb>
</span><span style=color:#bbb>        </span>UnsafeCell<span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span>);<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>impl</span><span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>Mut<span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>new</span><span style=color:#bbb> </span>(value: <span style=color:#b06;font-weight:700>T</span>)<span style=color:#bbb> </span>-&gt; <span style=color:#b06;font-weight:700>Self</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span>Self(UnsafeCell::new(value))<span style=color:#bbb>
</span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>unsafe</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>get</span><span style=color:#bbb> </span>(self: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#00c>&#39;_</span><span style=color:#bbb> </span>Self)<span style=color:#bbb> </span>-&gt; <span style=color:#b06;font-weight:700>T</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span>ptr::read(self.<span style=color:#60e;font-weight:700>0.</span>get())<span style=color:#bbb>
</span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#d42;background-color:#fff0f0>/// Look, mutation through a shared reference
</span><span style=color:#d42;background-color:#fff0f0></span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>unsafe</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>set</span><span style=color:#bbb> </span>(self: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#00c>&#39;_</span><span style=color:#bbb> </span>Self,<span style=color:#bbb> </span>value: <span style=color:#b06;font-weight:700>T</span>)<span style=color:#bbb>
</span><span style=color:#bbb>        </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span>ptr::write(self.<span style=color:#60e;font-weight:700>0.</span>get(),<span style=color:#bbb> </span>value);<span style=color:#bbb>
</span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><h5 id=cell-when-unsafecell-is-not-unsafe>Cell: when <code>UnsafeCell</code> is not <code>unsafe</code></h5><p>It turns out that the <code>.get()</code> and <code>set()</code> methods above can soundly be marked
non-<code>unsafe</code>, provided some additional guarantee:</p><ol><li><p>For it to be sound,
<strong><code>.get()</code> and <code>.set()</code> cannot be called <em>in parallel</em></strong>
(else we would have a data race).</p><ul><li><p>But <code>.get()</code> and <code>.set()</code> being called <em>in parallel</em> requires there
being shared references to the same cell from multiple threads.</p><p>And since <code>UnsafeCell&lt;T&gt; : !Sync</code>, this is not possible.</p></li></ul></li><li><p><strong><code>.get()</code> may cause a double free if <code>T</code> has drop glue</strong>.</p><ul><li>This can be fixed by <strong>adding a <code>T : Copy</code> bound</strong>,
since then there cannot be such drop glue.</li></ul></li></ol><p>TL,DR: given a wrapper around <code>UnsafeCell</code> (thus guaranteed not to be <code>Sync</code>),
the <code>.get()</code> and <code>.set()</code> methods are sound
(and thus do not require to be marked <code>unsafe</code>),
provided there is a <code>T : Copy</code> bound on <code>.get()</code>.</p><ul><li><p>That&rsquo;s exactly what <strong><code>Cell</code></strong> is: a thread-local wrapper for <code>Copy</code>
types such as integers (or shared references), that provides non-<code>unsafe</code>
Aliased Mutability and thus let us write classical C-programming patterns.</p><ul><li>The <code>T : Copy</code> is technically not needed (memory-safety-wise) on the
<code>.set()</code> method, but it would then be easy to misuse <code>Cell</code> and cause
memory leaks with it (a memory leak, although annoying, is memory safe).</li></ul></li></ul><hr><p>We can now write down a non-<code>unsafe</code> solution to our problem.</p><h4 id=solution>Solution</h4><a class=inline-svg href="https://play.rust-lang.org/?edition=2018&code=%23%21%5bforbid%28unsafe_code%29%5d%20%2f%2f%20no%20more%20unsafe%2c%20we%20promise%0a%0ause%20%3a%3acore%3a%3acell%3a%3aCell%3b%0a%0a%23%5ballow%28non_camel_case_types%29%5d%0atype%20int%20%3d%20i32%3b%0a%0afn%20main%20%28%29%0a%7b%0a%20%20%20%20let%20x%3a%20Cell%3cint%3e%20%3d%20Cell%3a%3anew%2842%29%3b%0a%20%20%20%20let%20p1%3a%20%26Cell%3cint%3e%20%3d%20%26x%3b%0a%20%20%20%20let%20p2%3a%20%26Cell%3cint%3e%20%3d%20%26x%3b%0a%20%20%20%20p2.set%28p2.get%28%29%20%2b%2027%29%3b%0a%20%20%20%20println%21%28%22x%20%3d%20%7b%7d%22%2c%20p1.get%28%29%29%3b%0a%7d%0a" target=_blank><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="#606060" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#579>#![forbid(unsafe_code)]</span><span style=color:#bbb> </span><span style=color:#888>// no more unsafe, we promise
</span><span style=color:#888></span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>use</span><span style=color:#bbb> </span>::core::cell::Cell;<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#579>#[allow(non_camel_case_types)]</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>type</span> <span style=color:#b06;font-weight:700>int</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>i32</span>;<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>main</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>x: <span style=color:#b06;font-weight:700>Cell</span><span style=color:#333>&lt;</span>int<span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>Cell::new(<span style=color:#00d;font-weight:700>42</span>);<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>p1: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>Cell</span><span style=color:#333>&lt;</span>int<span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span>x;<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>p2: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>Cell</span><span style=color:#333>&lt;</span>int<span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span>x;<span style=color:#bbb>
</span><span style=color:#bbb>    </span>p2.set(p2.get()<span style=color:#bbb> </span><span style=color:#333>+</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>27</span>);<span style=color:#bbb>
</span><span style=color:#bbb>    </span>println<span style=color:#333>!</span>(<span style=background-color:#fff0f0>&#34;x = {}&#34;</span>,<span style=color:#bbb> </span>p1.get());<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><p>As you can see, <strong><code>UnsafeCell</code> is a mutability wrapper</strong>,
providing the raw (and thus <code>unsafe</code>) semantics of <code>C</code>:
mutation through a <em>shared</em> reference. In other words,</p><p><img src=https://i.imgflip.com/2v22n0.jpg alt="Interior Mutability"></p><blockquote><p><strong>Interior Mutability</strong>: mutation through a <em>shared</em> reference</p></blockquote><ul><li>Also called &ndash;at least by me&ndash; <em>Aliased Mutability</em></li></ul><p>Remember, the signature of <code>UnsafeCell::get</code> is:</p><blockquote><p><code>&amp;UnsafeCell&lt;T&gt; -&gt; *mut T</code></p></blockquote><p>which means that an <code>UnsafeCell&lt;_&gt;</code> wraps data and provides a (<code>*mut</code>) handle to its interior, with which we can mutate the wrapped data: <strong>the <em>interior</em> of the wrapper is <em>mutable</em></strong>, even when the reference to the <code>UnsafeCell&lt;_&gt;</code> is not guaranteed to be unique.</p><p>The fact is that &ndash; whether with <code>Cell&lt;int&gt;</code> (which is a (safe) wrapper for <code>UnsafeCell</code>)
or <code>UnsafeCell</code> directly &ndash; we have:</p><blockquote><p><strong>mutable aliased reference to a <code>T</code> == <code>&amp;UnsafeCell&lt;T&gt;</code></strong></p></blockquote><p>And more generally, any wrapper that may allow mutation through a non-unique
reference will wrap the part that can be mutated in an <code>UnsafeCell</code>.</p><p>In other words: there cannot be interior mutability / aliased mutability without
<code>UnsafeCell</code>.</p><h3 id=mutable-fields>Mutable fields</h3><p>So, for those wondering how to express in Rust that a particular field in a struct is mutable,
the answer is:</p><ul><li><p>from within a (guaranteed) <strong>unique</strong> reference, <strong>everything</strong> is mutable.</p></li><li><p>from within a (potentially) <strong>shared</strong> reference,
the field needs to be wrapped within a type offering Aliased Mutability.</p></li></ul><h4 id=example-rc>Example: <code>Rc</code></h4><p><code>Rc</code> is a smart pointer offering <strong>shared ownership</strong>.
That is, <strong>even if you <em>own</em> a <code>Rc&lt;T&gt;</code>, you may <em>not be the only one</em> having access
to the pointee</strong> <code>T</code>. Hence:</p><ul><li><p>dropping a <code>Rc&lt;T&gt;</code> may not drop the pointee
(it will only do so when it knows, with a runtime check,
that it is indeed the last and thus unique owner of the pointee);</p></li><li><p><code>Rc&lt;T&gt; : Deref&lt;Target = T&gt;</code>, but <code>Rc&lt;T&gt;</code> does not offer a zero-cost
<code>DerefMut</code> API (<code>&amp;'_ mut Rc&lt;T&gt; -&gt; &amp;'_ mut T</code>):
how could it possibly offer such a function,
when having a unique handle on <em>one</em> <code>Rc&lt;T&gt;</code> does not guarantee that you
have a unique handle on the pointee?</p></li></ul><p>The runtime check and general functionality of <code>Rc</code> is described by its name:
reference <strong>counting</strong>.</p><p>That is, a<sup class=footnote-ref id=fnref:3><a href=#fn:3>3</a></sup> counter is appended to the pointee (in heap memory), initially
set to <code>1</code> by <code>Rc::new</code>.</p><p>Then, each time <code>Rc::clone()</code> is called, that counter is incremented;
and every time a <code>Rc</code> is <code>drop</code>ped, that counter is decremented.
Unicity can thus be known at runtime by reading that counter.</p><blockquote><p>But incrementing a counter means mutating it, and <code>Clone::clone</code> signature
only requires a <strong>shared</strong> reference on its input!</p></blockquote><p>Yes, it is time for Aliased Mutability to shine:</p><a class=inline-svg href="https://play.rust-lang.org/?edition=2018&code=use%20%3a%3astd%3a%3a%7b%0a%20%20%20%20cell%3a%3aCell%2c%0a%20%20%20%20mem%3a%3adrop%2c%0a%20%20%20%20ops%3a%3aDeref%2c%0a%7d%3b%0a%0a%2f%2f%2f%20This%20is%20the%20layout%20of%20the%20value%20in%20the%20heap%3a%0astruct%20RefCounted%3cT%3e%20%7b%0a%20%20%20%20%2f%2f%2f%20The%20value%20itself%0a%20%20%20%20value%3a%20T%2c%0a%0a%20%20%20%20%2f%2f%2f%20with%20a%20counter%20next%20to%20it%0a%20%20%20%20counter%3a%20Cell%3cusize%3e%2c%20%2f%2f%20%22mutable%22%20thanks%20to%20the%20%60Cell%60%0a%7d%0a%0a%2f%2f%2f%20A%20Rc%3cT%3e%20is%20a%20pointer%20to%20a%20heap-allocated%20value%20and%20a%20counter.%0apub%0astruct%20BasicRc%3cT%3e%20%7b%0a%20%20%20%20ptr%3a%20%2aconst%20RefCounted%3cT%3e%2c%0a%7d%0a%0aimpl%3cT%3e%20BasicRc%3cT%3e%20%7b%0a%20%20%20%20pub%0a%20%20%20%20fn%20new%20%28value%3a%20T%29%20-%3e%20Self%0a%20%20%20%20%7b%0a%20%20%20%20%20%20%20%20%2f%2f%20append%20a%20new%20counter%20to%20the%20value%0a%20%20%20%20%20%20%20%20let%20value_with_counter%20%3d%20RefCounted%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20value%2c%0a%20%20%20%20%20%20%20%20%20%20%20%20counter%3a%20Cell%3a%3anew%281%29%2c%0a%20%20%20%20%20%20%20%20%7d%3b%0a%20%20%20%20%20%20%20%20%2f%2f%20let%27s%20move%20it%20into%20to%20heap%3a%0a%20%20%20%20%20%20%20%20let%20boxed_value_with_counter%3a%20Box%3cRefCounted%3cT%3e%3e%20%3d%0a%20%20%20%20%20%20%20%20%20%20%20%20Box%3a%3anew%28value_with_counter%29%0a%20%20%20%20%20%20%20%20%3b%0a%20%20%20%20%20%20%20%20%2f%2f%20since%20we%20will%20be%20the%20ones%20managing%20the%20memory%2c%0a%20%20%20%20%20%20%20%20%2f%2f%20let%27s%20extract%20the%20underlying%20raw%20pointer%3a%0a%20%20%20%20%20%20%20%20let%20raw_ptr%20%3d%20Box%3a%3ainto_raw%28boxed_value_with_counter%29%3b%0a%20%20%20%20%20%20%20%20%2f%2f%20and%20return%0a%20%20%20%20%20%20%20%20Self%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20ptr%3a%20raw_ptr%2c%0a%20%20%20%20%20%20%20%20%7d%0a%20%20%20%20%7d%0a%0a%20%20%20%20%2f%2f%20private%0a%20%20%20%20fn%20at_counter%20%28self%3a%20%26%27_%20Self%29%20-%3e%20%26%27_%20Cell%3cusize%3e%0a%20%20%20%20%7b%0a%20%20%20%20%20%20%20%20unsafe%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20%26%28%2aself.ptr%29.counter%0a%20%20%20%20%20%20%20%20%7d%0a%20%20%20%20%7d%0a%7d%0a%0aimpl%3cT%3e%20Deref%20for%20BasicRc%3cT%3e%20%7b%0a%20%20%20%20type%20Target%20%3d%20T%3b%0a%0a%20%20%20%20%2f%2f%2f%20While%20%60Self%60%20is%20borrowed%20it%20is%20sound%20to%20borrow%20the%20value%2c%0a%20%20%20%20%2f%2f%2f%20but%20only%20in%20a%20shared%20fashion.%0a%20%20%20%20fn%20deref%20%28self%3a%20%26%27_%20Self%29%20-%3e%20%26%27_%20T%0a%20%20%20%20%7b%0a%20%20%20%20%20%20%20%20unsafe%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20%26%28%2aself.ptr%29.value%0a%20%20%20%20%20%20%20%20%7d%0a%20%20%20%20%7d%0a%7d%0a%0aimpl%3cT%3e%20Clone%20for%20BasicRc%3cT%3e%20%7b%0a%20%20%20%20fn%20clone%20%28self%3a%20%26%27_%20Self%29%20-%3e%20Self%0a%20%20%20%20%7b%0a%20%20%20%20%20%20%20%20let%20at_counter%3a%20%26Cell%3cusize%3e%20%3d%20self.at_counter%28%29%3b%0a%20%20%20%20%20%20%20%20%2f%2f%20increment%20counter%0a%20%20%20%20%20%20%20%20at_counter.set%28%0a%20%20%20%20%20%20%20%20%20%20%20%20at_counter%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20.get%28%29%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20.checked_add%281%29%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20.expect%28%22Counter%20integer%20overflow%22%29%0a%20%20%20%20%20%20%20%20%29%3b%0a%20%20%20%20%20%20%20%20%2f%2f%20having%20incremented%20the%20counter%2c%20we%20can%20copy%20the%20pointer%0a%20%20%20%20%20%20%20%20Self%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20ptr%3a%20self.ptr%2c%0a%20%20%20%20%20%20%20%20%7d%0a%20%20%20%20%7d%0a%7d%0a%0aimpl%3cT%3e%20Drop%20for%20BasicRc%3cT%3e%20%7b%0a%20%20%20%20fn%20drop%20%28self%3a%20%26%27_%20mut%20Self%29%0a%20%20%20%20%7b%0a%20%20%20%20%20%20%20%20let%20at_counter%3a%20%26Cell%3cusize%3e%20%3d%20self.at_counter%28%29%3b%0a%20%20%20%20%20%20%20%20%2f%2f%20decrement%20counter%20%28no%20need%20to%20check%20for%20underflow%29%0a%20%20%20%20%20%20%20%20at_counter.set%28at_counter.get%28%29%20-%201%29%3b%0a%20%20%20%20%20%20%20%20%2f%2f%20the%20counter%20is%200%20if%20and%20only%20if%20we%20are%20the%20last%20owner%0a%20%20%20%20%20%20%20%20if%20at_counter.get%28%29%20%3d%3d%200%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20%2f%2f%20since%20we%20are%20the%20last%20owner%2c%0a%20%20%20%20%20%20%20%20%20%20%20%20%2f%2f%20we%20are%20back%20to%20being%20just%20a%20Box%3a%0a%20%20%20%20%20%20%20%20%20%20%20%20let%20boxed_value_with_counter%20%3d%20unsafe%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Box%3a%3afrom_raw%28self.ptr%20as%20%2amut%20_%29%0a%20%20%20%20%20%20%20%20%20%20%20%20%7d%3b%0a%20%20%20%20%20%20%20%20%20%20%20%20%2f%2f%20time%20to%20deallocate%2c%20by%20dropping%20the%20%60Box%60%0a%20%20%20%20%20%20%20%20%20%20%20%20drop%3a%3a%3cBox%3cRefCounted%3cT%3e%3e%3e%28%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20boxed_value_with_counter%0a%20%20%20%20%20%20%20%20%20%20%20%20%29%3b%0a%20%20%20%20%20%20%20%20%7d%0a%20%20%20%20%7d%0a%7d%0a" target=_blank><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="#606060" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#080;font-weight:700>use</span><span style=color:#bbb> </span>::std::{<span style=color:#bbb>
</span><span style=color:#bbb>    </span>cell::Cell,<span style=color:#bbb>
</span><span style=color:#bbb>    </span>mem::drop,<span style=color:#bbb>
</span><span style=color:#bbb>    </span>ops::Deref,<span style=color:#bbb>
</span><span style=color:#bbb></span>};<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#d42;background-color:#fff0f0>/// This is the layout of the value in the heap:
</span><span style=color:#d42;background-color:#fff0f0></span><span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>RefCounted</span><span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#d42;background-color:#fff0f0>/// The value itself
</span><span style=color:#d42;background-color:#fff0f0></span><span style=color:#bbb>    </span>value: <span style=color:#b06;font-weight:700>T</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#d42;background-color:#fff0f0>/// with a counter next to it
</span><span style=color:#d42;background-color:#fff0f0></span><span style=color:#bbb>    </span>counter: <span style=color:#b06;font-weight:700>Cell</span><span style=color:#333>&lt;</span><span style=color:#339;font-weight:700>usize</span><span style=color:#333>&gt;</span>,<span style=color:#bbb> </span><span style=color:#888>// &#34;mutable&#34; thanks to the `Cell`
</span><span style=color:#888></span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#d42;background-color:#fff0f0>/// A Rc&lt;T&gt; is a pointer to a heap-allocated value and a counter.
</span><span style=color:#d42;background-color:#fff0f0></span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>BasicRc</span><span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span>ptr: <span style=color:#333>*</span><span style=color:#080;font-weight:700>const</span><span style=color:#bbb> </span>RefCounted<span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span>,<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>impl</span><span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>BasicRc<span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>new</span><span style=color:#bbb> </span>(value: <span style=color:#b06;font-weight:700>T</span>)<span style=color:#bbb> </span>-&gt; <span style=color:#b06;font-weight:700>Self</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#888>// append a new counter to the value
</span><span style=color:#888></span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>value_with_counter<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>RefCounted<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span>value,<span style=color:#bbb>
</span><span style=color:#bbb>            </span>counter: <span style=color:#b06;font-weight:700>Cell</span>::new(<span style=color:#00d;font-weight:700>1</span>),<span style=color:#bbb>
</span><span style=color:#bbb>        </span>};<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#888>// let&#39;s move it into to heap:
</span><span style=color:#888></span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>boxed_value_with_counter: <span style=color:#007020>Box</span><span style=color:#333>&lt;</span>RefCounted<span style=color:#333>&lt;</span>T<span style=color:#333>&gt;&gt;</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#007020>Box</span>::new(value_with_counter)<span style=color:#bbb>
</span><span style=color:#bbb>        </span>;<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#888>// since we will be the ones managing the memory,
</span><span style=color:#888></span><span style=color:#bbb>        </span><span style=color:#888>// let&#39;s extract the underlying raw pointer:
</span><span style=color:#888></span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>raw_ptr<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#007020>Box</span>::into_raw(boxed_value_with_counter);<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#888>// and return
</span><span style=color:#888></span><span style=color:#bbb>        </span>Self<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span>ptr: <span style=color:#b06;font-weight:700>raw_ptr</span>,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#888>// private
</span><span style=color:#888></span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>at_counter</span><span style=color:#bbb> </span>(self: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#00c>&#39;_</span><span style=color:#bbb> </span>Self)<span style=color:#bbb> </span>-&gt; <span style=color:#038;font-weight:700>&amp;</span><span style=color:#00c>&#39;_</span><span style=color:#bbb> </span>Cell<span style=color:#333>&lt;</span><span style=color:#339;font-weight:700>usize</span><span style=color:#333>&gt;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>unsafe</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#333>&amp;</span>(<span style=color:#333>*</span>self.ptr).counter<span style=color:#bbb>
</span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>impl</span><span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>Deref<span style=color:#bbb> </span><span style=color:#080;font-weight:700>for</span><span style=color:#bbb> </span>BasicRc<span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>type</span> <span style=color:#b06;font-weight:700>Target</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>T;<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#d42;background-color:#fff0f0>/// While `Self` is borrowed it is sound to borrow the value,
</span><span style=color:#d42;background-color:#fff0f0></span><span style=color:#bbb>    </span><span style=color:#d42;background-color:#fff0f0>/// but only in a shared fashion.
</span><span style=color:#d42;background-color:#fff0f0></span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>deref</span><span style=color:#bbb> </span>(self: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#00c>&#39;_</span><span style=color:#bbb> </span>Self)<span style=color:#bbb> </span>-&gt; <span style=color:#038;font-weight:700>&amp;</span><span style=color:#00c>&#39;_</span><span style=color:#bbb> </span>T<span style=color:#bbb>
</span><span style=color:#bbb>    </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>unsafe</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#333>&amp;</span>(<span style=color:#333>*</span>self.ptr).value<span style=color:#bbb>
</span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>impl</span><span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#007020>Clone</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>for</span><span style=color:#bbb> </span>BasicRc<span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>clone</span><span style=color:#bbb> </span>(self: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#00c>&#39;_</span><span style=color:#bbb> </span>Self)<span style=color:#bbb> </span>-&gt; <span style=color:#b06;font-weight:700>Self</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>at_counter: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>Cell</span><span style=color:#333>&lt;</span><span style=color:#339;font-weight:700>usize</span><span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>self.at_counter();<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#888>// increment counter
</span><span style=color:#888></span><span style=color:#bbb>        </span>at_counter.set(<span style=color:#bbb>
</span><span style=color:#bbb>            </span>at_counter<span style=color:#bbb>
</span><span style=color:#bbb>                </span>.get()<span style=color:#bbb>
</span><span style=color:#bbb>                </span>.checked_add(<span style=color:#00d;font-weight:700>1</span>)<span style=color:#bbb>
</span><span style=color:#bbb>                </span>.expect(<span style=background-color:#fff0f0>&#34;Counter integer overflow&#34;</span>)<span style=color:#bbb>
</span><span style=color:#bbb>        </span>);<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#888>// having incremented the counter, we can copy the pointer
</span><span style=color:#888></span><span style=color:#bbb>        </span>Self<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span>ptr: <span style=color:#b06;font-weight:700>self</span>.ptr,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>impl</span><span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#007020>Drop</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>for</span><span style=color:#bbb> </span>BasicRc<span style=color:#333>&lt;</span>T<span style=color:#333>&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>drop</span><span style=color:#bbb> </span>(self: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#00c>&#39;_</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>Self)<span style=color:#bbb>
</span><span style=color:#bbb>    </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>at_counter: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#b06;font-weight:700>Cell</span><span style=color:#333>&lt;</span><span style=color:#339;font-weight:700>usize</span><span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>self.at_counter();<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#888>// decrement counter (no need to check for underflow)
</span><span style=color:#888></span><span style=color:#bbb>        </span>at_counter.set(at_counter.get()<span style=color:#bbb> </span><span style=color:#333>-</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>1</span>);<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#888>// the counter is 0 if and only if we are the last owner
</span><span style=color:#888></span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>if</span><span style=color:#bbb> </span>at_counter.get()<span style=color:#bbb> </span><span style=color:#333>==</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>0</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#888>// since we are the last owner,
</span><span style=color:#888></span><span style=color:#bbb>            </span><span style=color:#888>// we are back to being just a Box:
</span><span style=color:#888></span><span style=color:#bbb>            </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>boxed_value_with_counter<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>unsafe</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:#007020>Box</span>::from_raw(self.ptr<span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#333>*</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>_)<span style=color:#bbb>
</span><span style=color:#bbb>            </span>};<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#888>// time to deallocate, by dropping the `Box`
</span><span style=color:#888></span><span style=color:#bbb>            </span>drop::<span style=color:#333>&lt;</span><span style=color:#007020>Box</span><span style=color:#333>&lt;</span>RefCounted<span style=color:#333>&lt;</span>T<span style=color:#333>&gt;&gt;&gt;</span>(<span style=color:#bbb>
</span><span style=color:#bbb>                </span>boxed_value_with_counter<span style=color:#bbb>
</span><span style=color:#bbb>            </span>);<span style=color:#bbb>
</span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><h2 id=sync><code>Sync</code></h2><p>This trait was quickly mentioned before when talking about why / how <code>Cell</code> is
sound despite it allowing mutation through an aliased / shared reference.</p><h3 id=data-race>Data Race</h3><p>This happens when a place in memory is being read<sup class=footnote-ref id=fnref:4><a href=#fn:4>4</a></sup> at the same time that
it is being written to, which can lead to extraneous values being read and
thus nasty bugs.</p><h4 id=basic-example-race-condition>Basic Example (race condition)</h4><a class=inline-svg href="https://play.rust-lang.org/?edition=2018&code=use%20%3a%3acrossbeam%3a%3a%7b%0a%20%20%20%20atomic%3a%3aAtomicCell%2c%0a%20%20%20%20thread%2c%0a%7d%3b%0a%0a%23%5bderive%28Debug%2c%20Default%29%5d%0astruct%20Twins%20%7b%0a%20%20%20%20thomson%3a%20AtomicCell%3cbool%3e%2c%0a%20%20%20%20thompson%3a%20AtomicCell%3cbool%3e%2c%0a%7d%0a%0aimpl%20Twins%20%7b%0a%20%20%20%20%2f%2f%2f%20The%20struct%20invariant%3a%20%60thomson%20%3d%3d%20thompson%60%0a%20%20%20%20fn%20assert_equal%20%28self%3a%20%26%27_%20Self%29%0a%20%20%20%20%7b%0a%20%20%20%20%20%20%20%20if%20self.thomson.load%28%29%20%21%3d%20self.thompson.load%28%29%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20eprintln%21%28%22Error%2c%20twins%20are%20not%20equal%22%29%3b%0a%20%20%20%20%20%20%20%20%20%20%20%20%3a%3astd%3a%3aprocess%3a%3aabort%28%29%3b%20%2f%2f%20kill%20all%20threads%0a%20%20%20%20%20%20%20%20%7d%0a%20%20%20%20%7d%0a%0a%20%20%20%20fn%20set_all%20%28self%3a%20%26%27_%20Self%2c%20value%3a%20bool%29%0a%20%20%20%20%7b%0a%20%20%20%20%20%20%20%20self.thomson.store%28value%29%3b%0a%20%20%20%20%20%20%20%20self.thompson.store%28value%29%3b%0a%20%20%20%20%7d%0a%7d%0a%0afn%20main%20%28%29%0a%7b%0a%20%20%20%20let%20twins%20%3d%20Twins%3a%3adefault%28%29%3b%0a%20%20%20%20thread%3a%3ascope%28%7cscope%7c%20%7b%0a%20%20%20%20%20%20%20%20scope.spawn%28%7c_%7c%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20%2f%2f%20Thread%201%0a%20%20%20%20%20%20%20%20%20%20%20%20loop%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20twins.assert_equal%28%29%3b%0a%20%20%20%20%20%20%20%20%20%20%20%20%7d%0a%20%20%20%20%20%20%20%20%7d%29%3b%0a%20%20%20%20%20%20%20%20scope.spawn%28%7c_%7c%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20%2f%2f%20Thread%202%0a%20%20%20%20%20%20%20%20%20%20%20%20let%20mut%20next%20%3d%20true%3b%0a%20%20%20%20%20%20%20%20%20%20%20%20loop%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20twins.set_all%28next%29%3b%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20next%20%3d%20%21next%3b%0a%20%20%20%20%20%20%20%20%20%20%20%20%7d%0a%20%20%20%20%20%20%20%20%7d%29%3b%0a%20%20%20%20%7d%29.expect%28%22Some%20thread%20panicked%22%29%3b%0a%7d%0a" target=_blank><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="#606060" d="M424.4 214.7 72.4 6.6C43.8-10.3.0 6.1.0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1.0-82.6z"/></svg></a><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#080;font-weight:700>use</span><span style=color:#bbb> </span>::crossbeam::{<span style=color:#bbb>
</span><span style=color:#bbb>    </span>atomic::AtomicCell,<span style=color:#bbb>
</span><span style=color:#bbb>    </span>thread,<span style=color:#bbb>
</span><span style=color:#bbb></span>};<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#579>#[derive(Debug, Default)]</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>Twins</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span>thomson: <span style=color:#b06;font-weight:700>AtomicCell</span><span style=color:#333>&lt;</span><span style=color:#339;font-weight:700>bool</span><span style=color:#333>&gt;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span>thompson: <span style=color:#b06;font-weight:700>AtomicCell</span><span style=color:#333>&lt;</span><span style=color:#339;font-weight:700>bool</span><span style=color:#333>&gt;</span>,<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>impl</span><span style=color:#bbb> </span>Twins<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#d42;background-color:#fff0f0>/// The struct invariant: `thomson == thompson`
</span><span style=color:#d42;background-color:#fff0f0></span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>assert_equal</span><span style=color:#bbb> </span>(self: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#00c>&#39;_</span><span style=color:#bbb> </span>Self)<span style=color:#bbb>
</span><span style=color:#bbb>    </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>if</span><span style=color:#bbb> </span>self.thomson.load()<span style=color:#bbb> </span><span style=color:#333>!=</span><span style=color:#bbb> </span>self.thompson.load()<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span>eprintln<span style=color:#333>!</span>(<span style=background-color:#fff0f0>&#34;Error, twins are not equal&#34;</span>);<span style=color:#bbb>
</span><span style=color:#bbb>            </span>::std::process::abort();<span style=color:#bbb> </span><span style=color:#888>// kill all threads
</span><span style=color:#888></span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>set_all</span><span style=color:#bbb> </span>(self: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#00c>&#39;_</span><span style=color:#bbb> </span>Self,<span style=color:#bbb> </span>value: <span style=color:#339;font-weight:700>bool</span>)<span style=color:#bbb>
</span><span style=color:#bbb>    </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span>self.thomson.store(value);<span style=color:#bbb>
</span><span style=color:#bbb>        </span>self.thompson.store(value);<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>main</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>twins<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>Twins::default();<span style=color:#bbb>
</span><span style=color:#bbb>    </span>thread::scope(<span style=color:#333>|</span>scope<span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span>scope.spawn(<span style=color:#333>|</span>_<span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#888>// Thread 1
</span><span style=color:#888></span><span style=color:#bbb>            </span><span style=color:#080;font-weight:700>loop</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>                </span>twins.assert_equal();<span style=color:#bbb>
</span><span style=color:#bbb>            </span>}<span style=color:#bbb>
</span><span style=color:#bbb>        </span>});<span style=color:#bbb>
</span><span style=color:#bbb>        </span>scope.spawn(<span style=color:#333>|</span>_<span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#888>// Thread 2
</span><span style=color:#888></span><span style=color:#bbb>            </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>next<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>true</span>;<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#080;font-weight:700>loop</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>                </span>twins.set_all(next);<span style=color:#bbb>
</span><span style=color:#bbb>                </span>next<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>!</span>next;<span style=color:#bbb>
</span><span style=color:#bbb>            </span>}<span style=color:#bbb>
</span><span style=color:#bbb>        </span>});<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}).expect(<span style=background-color:#fff0f0>&#34;Some thread panicked&#34;</span>);<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><p>I won&rsquo;t go into the details of the above code (which uses an external crate for
convenience<sup class=footnote-ref id=fnref:5><a href=#fn:5>5</a></sup>), but suffices to say that the above code, while being
memory-safe (it compiles with no <code>unsafe</code> used), does suffer from a race
condition: even though the <code>Twins</code> are only modified through a method that sets
both fields to the same value, their &ldquo;all the fields have the same value&rdquo;
invariant is temporarily broken in between.</p><p>Since the struct is <code>Sync</code> (<em>i.e.</em>, it can be <strong>shared</strong> across multiple
threads without possibly causing memory unsafety), I was able to share it
across two threads, resulting in one of them witnessing the temporary broken
state of the other:</p><ul><li>We have had a race condition, or &ldquo;high-level data race&rdquo;.</li></ul><h4 id=data-races-and-memory-safety>Data races and memory safety</h4><p>In a similar fashion race condition also exist at the hardware level &ndash; called
<em>data races</em>: imagine a shared <code>32</code>-bit integer where only two values can be
written to it:</p><ul><li><p><code>0_i32</code> (the null bit pattern: <code>00...00</code>),</p></li><li><p>and <code>-1_i32</code> (the &ldquo;all ones&rdquo; bit-pattern: <code>11...11</code>),</p></li></ul><p>Let&rsquo;s see what can happen when these writes are not atomic, and happen instead,
<code>16</code> bits at a time (for instance<sup class=footnote-ref id=fnref:6><a href=#fn:6>6</a></sup>). If, at the same time, another thread of
execution reads this shared integer, then it may end up reading a bit-pattern
with <code>16</code> zeroes followed by <code>16</code> ones, or <em>viceversa</em>; resulting in it reading
the value <code>65535_i32</code> or <code>-65536_i32</code>.</p><p>The fact that the compiler does not guarantee any form of atomicity for standard
reads and writes (for the sake of performance) makes this kind of situation
&ndash;a data race&ndash; be Undefined Behavior:</p><p><img src=/img/this_is_fine_UB.jpg alt="Undefined Behavior"></p><p>This is what the <code>Sync</code> trait (and the underlying <code>Send</code>) is for:</p><blockquote><p><strong>a type is <code>Sync</code> if it can be (safely) shared across multiple threads</strong>.</p></blockquote><ul><li><p>It suffices for a type <strong>not to have Aliased Mutability</strong> to be <code>Sync</code>.
Indeed, if it is shared <del>across multiple</del> &ndash;yadda yadda&ndash;, then it is
aliased, and without Aliased Mutability, Rust forbids mutating it
(precisely for this reason).</p><ul><li><p>Examples: <code>String</code>, <code>Vec&lt;u8&gt;</code>, <code>bool</code>, etc.</p></li><li><p>Proof:
<a class=inline-svg href="https://play.rust-lang.org/?edition=2018&code=%2f%2f%21%20This%20should%20fail%0a%0ause%20%3a%3acrossbeam%3a%3athread%3b%0a%0afn%20main%20%28%29%0a%7b%0a%20%20%20%20let%20mut%20x%3a%20i32%20%3d%200%3b%0a%20%20%20%20thread%3a%3ascope%28%7cscope%7c%20%7b%0a%20%20%20%20%20%20%20%20scope.spawn%28%7c_%7c%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20%2f%2f%20Thread%201%0a%20%20%20%20%20%20%20%20%20%20%20%20let%20mut%20next%20%3d%20%210%3b%0a%20%20%20%20%20%20%20%20%20%20%20%20loop%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20x%20%3d%20next%3b%20%2f%2f%20%26mut%20i32%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20next%20%3d%20%21next%3b%0a%20%20%20%20%20%20%20%20%20%20%20%20%7d%0a%20%20%20%20%20%20%20%20%7d%29%3b%0a%20%20%20%20%20%20%20%20scope.spawn%28%7c_%7c%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20%2f%2f%20Thread%202%0a%20%20%20%20%20%20%20%20%20%20%20%20if%20x%20%21%3d%200%20%26%26%20x%20%21%3d%20%210%20%7b%20%2f%2f%20%26%20i32%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20eprintln%21%28%22UNDEFINED%20BEHAVIOR%22%29%3b%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3a%3astd%3a%3aprocess%3a%3aabort%28%29%3b%0a%20%20%20%20%20%20%20%20%20%20%20%20%7d%0a%20%20%20%20%20%20%20%20%7d%29%3b%0a%20%20%20%20%7d%29.expect%28%22Some%20thread%20panicked%22%29%3b%0a%7d%0a" target=_blank><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="#606060" d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937.0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154.0l239.94 416.028zM288 354c-25.405.0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346 7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373.0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884.0-12.356 5.78-11.981 12.654z"/></svg></a><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#080;font-weight:700>use</span><span style=color:#bbb> </span>::crossbeam::thread;<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>main</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>x: <span style=color:#339;font-weight:700>i32</span> <span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>0</span>;<span style=color:#bbb>
</span><span style=color:#bbb>    </span>thread::scope(<span style=color:#333>|</span>scope<span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span>scope.spawn(<span style=color:#333>|</span>_<span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#888>// Thread 1
</span><span style=color:#888></span><span style=color:#bbb>            </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>next<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>!</span><span style=color:#00d;font-weight:700>0</span>;<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#080;font-weight:700>loop</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>                </span>x<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>next;<span style=color:#bbb> </span><span style=color:#888>// &amp;mut i32
</span><span style=color:#888></span><span style=color:#bbb>                </span>next<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>!</span>next;<span style=color:#bbb>
</span><span style=color:#bbb>            </span>}<span style=color:#bbb>
</span><span style=color:#bbb>        </span>});<span style=color:#bbb>
</span><span style=color:#bbb>        </span>scope.spawn(<span style=color:#333>|</span>_<span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#888>// Thread 2
</span><span style=color:#888></span><span style=color:#bbb>            </span><span style=color:#080;font-weight:700>if</span><span style=color:#bbb> </span>x<span style=color:#bbb> </span><span style=color:#333>!=</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>0</span><span style=color:#bbb> </span><span style=color:#333>&amp;&amp;</span><span style=color:#bbb> </span>x<span style=color:#bbb> </span><span style=color:#333>!=</span><span style=color:#bbb> </span><span style=color:#333>!</span><span style=color:#00d;font-weight:700>0</span><span style=color:#bbb> </span>{<span style=color:#bbb> </span><span style=color:#888>// &amp; i32
</span><span style=color:#888></span><span style=color:#bbb>                </span>eprintln<span style=color:#333>!</span>(<span style=background-color:#fff0f0>&#34;UNDEFINED BEHAVIOR&#34;</span>);<span style=color:#bbb>
</span><span style=color:#bbb>                </span>::std::process::abort();<span style=color:#bbb>
</span><span style=color:#bbb>            </span>}<span style=color:#bbb>
</span><span style=color:#bbb>        </span>});<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}).expect(<span style=background-color:#fff0f0>&#34;Some thread panicked&#34;</span>);<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div></p></li></ul></li><li><p>If a type offers <strong>Aliased Mutability</strong>, then in order to be <code>Sync</code> it
needs to ensure within its public API that the mutations are thread-safe:</p><ul><li><p>either because they are atomic
(the case of <code>AtomicBool</code>, <code>AtomicI32</code>, etc.),</p></li><li><p>or because they use a synchronization mechanism (<code>RwLock</code>, <code>Mutex</code>, &hellip;)</p></li></ul></li></ul><p>This distinction is what makes it safe to have non-thread-safe Interior
Mutability, since by virtue of not being <code>!Sync</code>, Rust also forbids sharing such
values:</p><a class=inline-svg href="https://play.rust-lang.org/?edition=2018&code=%2f%2f%21%20This%20should%20fail%0a%0ause%20%3a%3astd%3a%3acell%3a%3aCell%3b%0ause%20%3a%3acrossbeam%3a%3athread%3b%0a%0afn%20main%20%28%29%0a%7b%0a%20%20%20%20let%20x%3a%20Cell%3ci32%3e%20%3d%20Cell%3a%3anew%280%29%3b%0a%20%20%20%20thread%3a%3ascope%28%7cscope%7c%20%7b%0a%20%20%20%20%20%20%20%20scope.spawn%28%7c_%7c%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20%2f%2f%20Thread%201%0a%20%20%20%20%20%20%20%20%20%20%20%20let%20mut%20next%20%3d%20%210%3b%0a%20%20%20%20%20%20%20%20%20%20%20%20loop%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20x.set%28next%29%3b%20%2f%2f%20%26Cell%3ci32%3e%20mutation%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20next%20%3d%20%21next%3b%0a%20%20%20%20%20%20%20%20%20%20%20%20%7d%0a%20%20%20%20%20%20%20%20%7d%29%3b%0a%20%20%20%20%20%20%20%20scope.spawn%28%7c_%7c%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20%2f%2f%20Thread%202%0a%20%20%20%20%20%20%20%20%20%20%20%20let%20x%20%3d%20x.get%28%29%3b%20%2f%2f%20%26Cell%3ci32%3e%20read%0a%20%20%20%20%20%20%20%20%20%20%20%20if%20x%20%21%3d%200%20%26%26%20x%20%21%3d%20%210%20%7b%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20eprintln%21%28%22UNDEFINED%20BEHAVIOR%22%29%3b%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3a%3astd%3a%3aprocess%3a%3aabort%28%29%3b%0a%20%20%20%20%20%20%20%20%20%20%20%20%7d%0a%20%20%20%20%20%20%20%20%7d%29%3b%0a%20%20%20%20%7d%29.expect%28%22Some%20thread%20panicked%22%29%3b%0a%7d%0a" target=_blank><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="#606060" d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937.0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154.0l239.94 416.028zM288 354c-25.405.0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346 7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373.0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884.0-12.356 5.78-11.981 12.654z"/></svg></a><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=color:#080;font-weight:700>use</span><span style=color:#bbb> </span>::std::cell::Cell;<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>use</span><span style=color:#bbb> </span>::crossbeam::thread;<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>main</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>x: <span style=color:#b06;font-weight:700>Cell</span><span style=color:#333>&lt;</span><span style=color:#339;font-weight:700>i32</span><span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>Cell::new(<span style=color:#00d;font-weight:700>0</span>);<span style=color:#bbb>
</span><span style=color:#bbb>    </span>thread::scope(<span style=color:#333>|</span>scope<span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span>scope.spawn(<span style=color:#333>|</span>_<span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#888>// Thread 1
</span><span style=color:#888></span><span style=color:#bbb>            </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>next<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>!</span><span style=color:#00d;font-weight:700>0</span>;<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#080;font-weight:700>loop</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>                </span>x.set(next);<span style=color:#bbb> </span><span style=color:#888>// &amp;Cell&lt;i32&gt; mutation
</span><span style=color:#888></span><span style=color:#bbb>                </span>next<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#333>!</span>next;<span style=color:#bbb>
</span><span style=color:#bbb>            </span>}<span style=color:#bbb>
</span><span style=color:#bbb>        </span>});<span style=color:#bbb>
</span><span style=color:#bbb>        </span>scope.spawn(<span style=color:#333>|</span>_<span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#888>// Thread 2
</span><span style=color:#888></span><span style=color:#bbb>            </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>x<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>x.get();<span style=color:#bbb> </span><span style=color:#888>// &amp;Cell&lt;i32&gt; read
</span><span style=color:#888></span><span style=color:#bbb>            </span><span style=color:#080;font-weight:700>if</span><span style=color:#bbb> </span>x<span style=color:#bbb> </span><span style=color:#333>!=</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>0</span><span style=color:#bbb> </span><span style=color:#333>&amp;&amp;</span><span style=color:#bbb> </span>x<span style=color:#bbb> </span><span style=color:#333>!=</span><span style=color:#bbb> </span><span style=color:#333>!</span><span style=color:#00d;font-weight:700>0</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>                </span>eprintln<span style=color:#333>!</span>(<span style=background-color:#fff0f0>&#34;UNDEFINED BEHAVIOR&#34;</span>);<span style=color:#bbb>
</span><span style=color:#bbb>                </span>::std::process::abort();<span style=color:#bbb>
</span><span style=color:#bbb>            </span>}<span style=color:#bbb>
</span><span style=color:#bbb>        </span>});<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}).expect(<span style=background-color:#fff0f0>&#34;Some thread panicked&#34;</span>);<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><hr><p>Okay, now that we have seen how interior mutability allows to
mutate certain values despite their being aliased, and how this interacts with
multi-threaded memory safety, it is time for an exhaustive list of <code>std</code>&rsquo;s &hellip;</p><h2 id=safe-abstractions-offering-aliased-mutability>Safe abstractions offering Aliased Mutability</h2><ul><li>(built on top of <code>UnsafeCell</code>)</li></ul><table><thead><tr><th align=center></th><th align=center><code>!Sync</code></th><th align=center><code>Sync</code></th></tr></thead><tbody><tr><td align=center><code>T</code></td><td align=center><code>RefCell&lt;T&gt;</code></td><td align=center><code>RwLock&lt;T&gt;</code> (and <code>Mutex&lt;T&gt;</code>)</td></tr><tr><td align=center><code>T : Copy</code></td><td align=center><code>Cell&lt;T&gt;</code></td><td align=center>X</td></tr><tr><td align=center>integer</td><td align=center><code>Cell&lt;{integer}&gt;</code></td><td align=center><code>Atomic{Integer}</code></td></tr><tr><td align=center>pointer</td><td align=center><code>Cell&lt;*mut T&gt;</code></td><td align=center><code>AtomicPtr</code></td></tr></tbody></table><h3 id=sync-wrappers-restricted-to-a-single-thread><code>!Sync</code> wrappers (restricted to a single thread):</h3><ul><li><p><strong><code>Cell&lt;T&gt;</code></strong></p><p>lets the programmer mutate <code>Copy</code> types (mainly).</p><ul><li><p><strong>This wrapper is zero-cost</strong>.</p></li><li><p>Examples:</p><ul><li><p>Numbers:</p><p><code>Cell&lt;bool&gt;, Cell&lt;u8&gt;, Cell&lt;i32&gt;, Cell&lt;u32&gt;, Cell&lt;usize&gt;</code>, &hellip;</p></li><li><p>Pointers:</p><p><code>Cell&lt;&amp;T&gt;</code>, <code>Cell&lt;*mut T&gt;</code>, &hellip;</p></li></ul></li></ul></li><li><p><strong><code>RefCell&lt;T&gt;</code></strong></p><p>lets the programmer obtain a <code>&amp;mut T</code> reference out of a <code>&amp;RefCell&lt;T&gt;</code>.
It&rsquo;s basically <code>UnsafeCell</code> but non-<code>unsafe</code> thanks to there being runtime
checks.</p><ul><li><p>runtime checks are based on <code>Cell</code>;</p></li><li><p>misusage leads to <strong>runtime <code>panic!</code>s</strong>!!</p></li><li><p>Examples:</p><ul><li><code>RefCell&lt;Vec&lt;_&gt;&gt;, RefCell&lt;String&gt;</code>, &hellip;</li></ul></li></ul></li></ul><h3 id=sync-wrappers-usable-across-multiple-threads><code>Sync</code> wrappers (usable across multiple threads)</h3><ul><li><p><strong><code>AtomicBool, AtomicU8, AtomicI32, AtomicU32, AtomicUsize, ...</code></strong></p><p>ensure that both the reads and the writes are atomic operations,
thus being memory safe in a multi-threaded context.</p><ul><li><p>Their API requires explicit atomic orderings, which is a very tough
topic on its own; when in doubt, always use <a href=https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html#variant.SeqCst><code>Ordering::SeqCst</code></a></p><ul><li>For a simpler and more flexible API, I must recommend using
<a href=https://docs.rs/crossbeam/0.7.1/crossbeam/atomic/struct.AtomicCell.html><code>::crossbeam::atomic::AtomicCell</code></a></li></ul></li></ul></li><li><p><strong><code>RwLock&lt;T&gt;</code> (and <code>Mutex&lt;T&gt;</code>)</strong></p><p>lets the programmer obtain a <code>&amp;mut T</code> reference out of a shared reference,
by virtue of making any other parallel access wait for the borrow to end.</p><ul><li><p>misusage leads to <strong>deadlocks or runtime <code>panic!</code>s</strong>!!</p></li><li><p>runtime checks are based on <code>atomic</code>s.</p></li><li><p><code>Mutex</code> is a slightly more performant version of <code>RwLock</code>, when using
only exclusive / write accesses.</p></li></ul></li></ul><hr><h2 id=application-safe-global-mutable-state>Application: <em>safe</em> global mutable state</h2><blockquote><p>Easy, the language itself offers <code>static mut</code>!</p></blockquote><p><strong>Do. Not. Use. <code>static mut</code>. Ever.</strong></p><p><img src=/img/one_does_not_simply_static_mut.jpg alt="One does not simply `static mut`"></p><p>Indeed, mutating a <code>static mut</code> has the (dis)honor of belonging to the room<sup class=footnote-ref id=fnref:7><a href=#fn:7>7</a></sup>
of Rust ill-designed patterns: doing it soundly is near impossible.
It will be deprecated in favor of an equivalent but safer construct<sup class=footnote-ref id=fnref:8><a href=#fn:8>8</a></sup>.</p><p>After all we have been through, it should now be easy to intuitively grasp why
<code>static mut</code> is an UB bomb in the Rust world:</p><ul><li><p><code>static</code>s are inherently <strong>aliased</strong> globally; It is as if there were</p><p><img src=/img/at_static_var_everywhere.jpg alt="`&amp; StaticVar` everywhere"></p></li><li><p>mutating a <code>static mut</code> is done through a <code>&amp;mut StaticVar</code> <strong>unique</strong> reference.</p><p><img src=/img/this_is_fine_UB.jpg alt="Undefined Behavior"></p></li></ul><p>The solution &ndash;you guessed it&ndash; is <code>UnsafeCell</code>:</p><ul><li>it is okay to mutate through a <code>&amp;mut StaticVar</code> (obtained from a
<code>&amp;UnsafeCell&lt;StaticVar&gt;</code>) even if there are other <code>&amp;UnsafeCell&lt;StaticVar&gt;</code>
around.</li></ul><p>Mutable <code>static</code> vars are, this way, less insane to use, since we can reuse
the safe <code>UnsafeCell</code>-based constructs seen above &ndash;actually only the <code>Sync</code>
ones, since a <code>static</code> is accessible from any thread:</p><ul><li><p>either <code>Atomic{Integer}</code>s,</p></li><li><p>or <code>RwLock&lt;T&gt;</code>.</p></li></ul><p>In general, I&rsquo;d still advise against using globale mutable state, since we
humans<sup class=footnote-ref id=fnref:9><a href=#fn:9>9</a></sup> are quite bad at non-local reasoning. However, in some simple cases,
it can be better than the cumbersome pattern of expliciting the additional
parameter everywhere.</p><p>One such example is a logger.</p><h3 id=concrete-example-our-own-basic-logger>Concrete example: our own basic logger</h3><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#579>#![forbid(unsafe_code)]</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#579>#[macro_use]</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>mod</span> <span style=color:#0e84b5;font-weight:700>logger</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>use</span><span style=color:#bbb> </span>::std::{<span style=color:#333>*</span>,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>fs::{<span style=color:#bbb>
</span><span style=color:#bbb>            </span>File,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>},<span style=color:#bbb>
</span><span style=color:#bbb>        </span>sync::{<span style=color:#bbb>
</span><span style=color:#bbb>            </span>atomic::{<span style=color:#bbb>
</span><span style=color:#bbb>                </span>AtomicU8,<span style=color:#bbb>
</span><span style=color:#bbb>                </span>Ordering,<span style=color:#bbb>
</span><span style=color:#bbb>            </span>},<span style=color:#bbb>
</span><span style=color:#bbb>            </span>Mutex,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>},<span style=color:#bbb>
</span><span style=color:#bbb>    </span>};<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>enum</span> <span style=color:#b06;font-weight:700>LoggerTarget</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span>Disabled,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>Stderr,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>File(File),<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#579>#[derive(Clone, Copy)]</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#579>#[repr(u8)]</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>enum</span> <span style=color:#b06;font-weight:700>LogLevel</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span>Error<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>1</span>,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>Warning,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>Info,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>Debug,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>Trace,<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>static</span><span style=color:#bbb> </span>LOG_LEVEL: <span style=color:#b06;font-weight:700>AtomicU8</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>AtomicU8::new(<span style=color:#00d;font-weight:700>0</span>);<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>::lazy_static::lazy_static<span style=color:#333>!</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>static</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>ref</span><span style=color:#bbb> </span>LOGGER: <span style=color:#b06;font-weight:700>Mutex</span><span style=color:#333>&lt;</span>LoggerTarget<span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span>Mutex::new(LoggerTarget::Disabled)<span style=color:#bbb>
</span><span style=color:#bbb>        </span>;<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>set_level</span><span style=color:#bbb> </span>(log_level: <span style=color:#b06;font-weight:700>LogLevel</span>)<span style=color:#bbb>
</span><span style=color:#bbb>    </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span>LOG_LEVEL.store(log_level<span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>u8</span>,<span style=color:#bbb> </span>Ordering::SeqCst);<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>disable</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style=color:#bbb>    </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>match</span><span style=color:#bbb> </span>LOGGER.lock()<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#333>|</span><span style=color:#bbb> </span><span style=color:#007020>Ok</span>(<span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>logger)<span style=color:#bbb> </span><span style=color:#333>=&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>                </span>LOG_LEVEL.store(<span style=color:#00d;font-weight:700>0</span>,<span style=color:#bbb> </span>Ordering::SeqCst);<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:#333>*</span>logger<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>LoggerTarget::Disabled;<span style=color:#bbb>
</span><span style=color:#bbb>            </span>},<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#333>|</span><span style=color:#bbb> </span><span style=color:#007020>Err</span>(_)<span style=color:#bbb> </span><span style=color:#333>=&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>                </span>panic<span style=color:#333>!</span>(<span style=background-color:#fff0f0>&#34;Logger was poisoned&#34;</span>);<span style=color:#bbb>
</span><span style=color:#bbb>            </span>}<span style=color:#bbb>
</span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>target_stderr</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style=color:#bbb>    </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#333>*</span>LOGGER.lock().expect(<span style=background-color:#fff0f0>&#34;Logger was poisoned&#34;</span>)<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span>LoggerTarget::Stderr<span style=color:#bbb>
</span><span style=color:#bbb>        </span>;<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>target_file</span><span style=color:#bbb> </span>(<span style=color:#bbb>
</span><span style=color:#bbb>        </span>filename: <span style=color:#b06;font-weight:700>impl</span><span style=color:#bbb> </span><span style=color:#007020>AsRef</span><span style=color:#333>&lt;</span>path::Path<span style=color:#333>&gt;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span>)<span style=color:#bbb> </span>-&gt; <span style=color:#b06;font-weight:700>io</span>::<span style=color:#007020>Result</span><span style=color:#333>&lt;</span>()<span style=color:#333>&gt;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>file<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span>fs::OpenOptions::new()<span style=color:#bbb>
</span><span style=color:#bbb>                </span>.write(<span style=color:#080;font-weight:700>true</span>)<span style=color:#bbb>
</span><span style=color:#bbb>                </span>.append(<span style=color:#080;font-weight:700>true</span>)<span style=color:#bbb>
</span><span style=color:#bbb>                </span>.create(<span style=color:#080;font-weight:700>true</span>)<span style=color:#bbb>
</span><span style=color:#bbb>                </span>.open(filename)<span style=color:#333>?</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>;<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>logger_target<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>LoggerTarget::File(file);<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#333>*</span>LOGGER.lock().expect(<span style=background-color:#fff0f0>&#34;Logger was poisoned&#34;</span>)<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span>logger_target<span style=color:#bbb>
</span><span style=color:#bbb>        </span>;<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#007020>Ok</span>(())<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>macro_rules<span style=color:#333>!</span><span style=color:#bbb> </span>log<span style=color:#bbb> </span>{(<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#579>$level</span>:<span style=color:#b06;font-weight:700>expr</span>,<span style=color:#bbb> </span><span style=color:#579>$($message</span>:<span style=color:#b06;font-weight:700>tt</span>)<span style=color:#333>*</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>)<span style=color:#bbb> </span><span style=color:#333>=&gt;</span><span style=color:#bbb> </span>(<span style=color:#080;font-weight:700>if</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#579>$crate</span>::logger::LOG_LEVEL.load(<span style=color:#bbb>
</span><span style=color:#bbb>            </span>::std::sync::atomic::Ordering::SeqCst<span style=color:#bbb>
</span><span style=color:#bbb>        </span>)<span style=color:#bbb> </span><span style=color:#333>&gt;=</span><span style=color:#bbb> </span>(<span style=color:#579>$level</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>u8</span>)<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>use</span><span style=color:#bbb> </span>::std::io::Write;<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>use</span><span style=color:#bbb> </span><span style=color:#579>$crate</span>::logger::{<span style=color:#bbb>
</span><span style=color:#bbb>            </span>LoggerTarget,<span style=color:#bbb>
</span><span style=color:#bbb>            </span>LOGGER,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>};<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>logger<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span>LOGGER<span style=color:#bbb>
</span><span style=color:#bbb>                </span>.lock()<span style=color:#bbb>
</span><span style=color:#bbb>                </span>.expect(<span style=background-color:#fff0f0>&#34;Logger was poisoned&#34;</span>)<span style=color:#bbb>
</span><span style=color:#bbb>        </span>;<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>match</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#333>*</span>logger<span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>LoggerTarget<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#333>|</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>LoggerTarget::Disabled<span style=color:#bbb> </span><span style=color:#333>=&gt;</span><span style=color:#bbb> </span>{},<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#333>|</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>LoggerTarget::Stderr<span style=color:#bbb> </span><span style=color:#333>=&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>                </span>eprintln<span style=color:#333>!</span>(<span style=color:#579>$($message</span>)<span style=color:#333>*</span>);<span style=color:#bbb>
</span><span style=color:#bbb>            </span>},<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#333>|</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>LoggerTarget::File(<span style=color:#080;font-weight:700>ref</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>file)<span style=color:#bbb> </span><span style=color:#333>=&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>                </span>writeln<span style=color:#333>!</span>(file,<span style=color:#bbb> </span><span style=color:#579>$($message</span>)<span style=color:#333>*</span>)<span style=color:#bbb>
</span><span style=color:#bbb>                    </span>.unwrap_or_else(<span style=color:#333>|</span>err<span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>                        </span><span style=color:#333>*</span>logger<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>LoggerTarget::Stderr;<span style=color:#bbb>
</span><span style=color:#bbb>                        </span>eprintln<span style=color:#333>!</span>(<span style=color:#bbb>
</span><span style=color:#bbb>                            </span><span style=background-color:#fff0f0>&#34;Writing to log file failed: {}&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>                            </span>err,<span style=color:#bbb>
</span><span style=color:#bbb>                        </span>);<span style=color:#bbb>
</span><span style=color:#bbb>                    </span>});<span style=color:#bbb>
</span><span style=color:#bbb>            </span>},<span style=color:#bbb>
</span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>})}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><ul><li><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=42acc059dfdbb886057ad1622dc22be6">Playground</a></li></ul><h4 id=remarks>Remarks</h4><ul><li><p>This is clearly not the most efficient implementation there can be, but it
gets the job done, featuring both:</p><ul><li><p>a <code>u8</code> global, used for the <code>LOG_LEVEL</code> (based on an atomic),</p></li><li><p>a more complex struct (<code>LoggerTarget</code>), requiring something like a
<code>Mutex</code>.</p><ul><li>Since <code>Mutex::new()</code> is not a <code>const fn</code> yet, it cannot be used to
initialise a <code>static</code>; hence the most idiomatic way around this
restriction is to use the <a href=https://docs.rs/lazy_static/1.3.0/lazy_static/><code>::lazy_static::lazy_static!</code></a>
macro to have a static with delayed initialisation, which lets thus
initialise a <code>static</code> with any kind of code.</li></ul></li></ul></li></ul><h3 id=thread-local-static><code>thread_local!(static)</code></h3><p>Remember when I said that we needed to use <code>Sync</code>-hronised Aliased Mutability
for a global variable? It turns out that <code>std</code> offers another &ldquo;global&rdquo;
construct:</p><blockquote><p><a href=https://doc.rust-lang.org/std/macro.thread_local.html><code>thread_local!(static ...)</code></a></p></blockquote><p>A static declaration wrapped in that macro will create a &ldquo;thread-local <code>static</code>&ldquo;:</p><ul><li><p>The &ldquo;global&rdquo; variable is then not global to the process but to each thread.</p><p>In other words, each thread has its own personal memory to back the
&ldquo;global&rdquo; variable, meaning that there is not <em>one</em> global variable but <code>n</code>
&ldquo;global&rdquo; variables, where <code>n</code> is the number of threads.</p><p>This design, in turn, means that <strong>a <code>thread_local!</code> cannot suffer from
data races</strong>, and thus does not require <code>Sync</code>-hronisation!</p></li><li><p>That&rsquo;s why types such as <code>Cell</code> and <code>RefCell</code> can actually be used with it.</p></li><li><p>The internals of the macro use (delayed) initialisation shenanigans similar
to <code>lazy_static!</code>&rsquo;s, meaning that you can use non <code>const</code> initialisation<sup class=footnote-ref id=fnref:10><a href=#fn:10>10</a></sup></p></li><li><p>Accessing a <code>thread_local!</code> is a little bit more cumbersome than a classic
<code>static</code>, since it requires <a href=https://en.wikipedia.org/wiki/Continuation-passing_style>Continuation Passing Style</a>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>thread_local<span style=color:#333>!</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>static</span><span style=color:#bbb> </span>FOO: <span style=color:#339;font-weight:700>i32</span> <span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>42</span>;<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>FOO.with(<span style=color:#333>|</span>foo: <span style=color:#038;font-weight:700>&amp;</span><span style=color:#339;font-weight:700>i32</span><span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#888>// foo is a temporary borrow to the thread local contents
</span><span style=color:#888></span><span style=color:#bbb>    </span>assert_eq<span style=color:#333>!</span>(<span style=color:#333>*</span>foo,<span style=color:#bbb> </span><span style=color:#00d;font-weight:700>42</span>);<span style=color:#bbb>
</span><span style=color:#bbb></span>})<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div></li></ul><h4 id=example-thread-local-logger>Example: <code>thread_local!</code> logger</h4><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#579>#![forbid(unsafe_code)]</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#579>#[macro_use]</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-weight:700>mod</span> <span style=color:#0e84b5;font-weight:700>logger</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>use</span><span style=color:#bbb> </span>::std::{<span style=color:#333>*</span>,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>cell::{<span style=color:#bbb>
</span><span style=color:#bbb>            </span>Cell,<span style=color:#bbb>
</span><span style=color:#bbb>            </span>RefCell,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>},<span style=color:#bbb>
</span><span style=color:#bbb>        </span>fs::{<span style=color:#bbb>
</span><span style=color:#bbb>            </span>File,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>},<span style=color:#bbb>
</span><span style=color:#bbb>    </span>};<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>enum</span> <span style=color:#b06;font-weight:700>LoggerTarget</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span>Disabled,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>Stderr,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>File(File),<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#579>#[derive(Clone, Copy)]</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#579>#[repr(u8)]</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>enum</span> <span style=color:#b06;font-weight:700>LogLevel</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span>Error<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span><span style=color:#00d;font-weight:700>1</span>,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>Warning,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>Info,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>Debug,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>Trace,<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>thread_local<span style=color:#333>!</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>static</span><span style=color:#bbb> </span>LOG_LEVEL: <span style=color:#b06;font-weight:700>Cell</span><span style=color:#333>&lt;</span><span style=color:#339;font-weight:700>u8</span><span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>Cell::new(<span style=color:#00d;font-weight:700>0</span>);<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>static</span><span style=color:#bbb> </span>LOGGER: <span style=color:#b06;font-weight:700>RefCell</span><span style=color:#333>&lt;</span>LoggerTarget<span style=color:#333>&gt;</span><span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span>RefCell::new(LoggerTarget::Disabled)<span style=color:#bbb>
</span><span style=color:#bbb>        </span>;<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>set_level</span><span style=color:#bbb> </span>(new_log_level: <span style=color:#b06;font-weight:700>LogLevel</span>)<span style=color:#bbb>
</span><span style=color:#bbb>    </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span>LOG_LEVEL.with(<span style=color:#080;font-weight:700>move</span><span style=color:#bbb> </span><span style=color:#333>|</span>log_level<span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span>log_level.set(new_log_level<span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>u8</span>);<span style=color:#bbb>
</span><span style=color:#bbb>        </span>});<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>disable</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style=color:#bbb>    </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span>LOG_LEVEL.with(<span style=color:#333>|</span>log_level<span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span>log_level.set(<span style=color:#00d;font-weight:700>0</span>);<span style=color:#bbb>
</span><span style=color:#bbb>        </span>});<span style=color:#bbb>
</span><span style=color:#bbb>        </span>LOGGER.with(<span style=color:#333>|</span>logger<span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#333>*</span>logger.borrow_mut()<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>LoggerTarget::Disabled;<span style=color:#bbb>
</span><span style=color:#bbb>        </span>});<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>target_stderr</span><span style=color:#bbb> </span>()<span style=color:#bbb>
</span><span style=color:#bbb>    </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span>LOGGER.with(<span style=color:#333>|</span>logger<span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#333>*</span>logger.borrow_mut()<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>LoggerTarget::Stderr;<span style=color:#bbb>
</span><span style=color:#bbb>        </span>});<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>pub</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-weight:700>fn</span> <span style=color:#06b;font-weight:700>target_file</span><span style=color:#bbb> </span>(<span style=color:#bbb>
</span><span style=color:#bbb>        </span>filename: <span style=color:#b06;font-weight:700>impl</span><span style=color:#bbb> </span><span style=color:#007020>AsRef</span><span style=color:#333>&lt;</span>path::Path<span style=color:#333>&gt;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span>)<span style=color:#bbb> </span>-&gt; <span style=color:#b06;font-weight:700>io</span>::<span style=color:#007020>Result</span><span style=color:#333>&lt;</span>()<span style=color:#333>&gt;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span>LOGGER.with(<span style=color:#080;font-weight:700>move</span><span style=color:#bbb> </span><span style=color:#333>|</span>logger<span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>file<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb>
</span><span style=color:#bbb>                </span>fs::OpenOptions::new()<span style=color:#bbb>
</span><span style=color:#bbb>                    </span>.write(<span style=color:#080;font-weight:700>true</span>)<span style=color:#bbb>
</span><span style=color:#bbb>                    </span>.append(<span style=color:#080;font-weight:700>true</span>)<span style=color:#bbb>
</span><span style=color:#bbb>                    </span>.create(<span style=color:#080;font-weight:700>true</span>)<span style=color:#bbb>
</span><span style=color:#bbb>                    </span>.open(filename)<span style=color:#333>?</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span>;<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span>logger_target<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>LoggerTarget::File(file);<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#333>*</span>logger.borrow_mut()<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>logger_target;<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#007020>Ok</span>(())<span style=color:#bbb>
</span><span style=color:#bbb>        </span>})<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>macro_rules<span style=color:#333>!</span><span style=color:#bbb> </span>log<span style=color:#bbb> </span>{(<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#579>$level</span>:<span style=color:#b06;font-weight:700>expr</span>,<span style=color:#bbb> </span><span style=color:#579>$($message</span>:<span style=color:#b06;font-weight:700>tt</span>)<span style=color:#333>*</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>)<span style=color:#bbb> </span><span style=color:#333>=&gt;</span><span style=color:#bbb> </span>(<span style=color:#080;font-weight:700>if</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#579>$crate</span>::logger::LOG_LEVEL.with(<span style=color:#bbb>
</span><span style=color:#bbb>            </span>::core::cell::Cell::get<span style=color:#bbb>
</span><span style=color:#bbb>        </span>)<span style=color:#bbb> </span><span style=color:#333>&gt;=</span><span style=color:#bbb> </span>(<span style=color:#579>$level</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#339;font-weight:700>u8</span>)<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>use</span><span style=color:#bbb> </span>::std::io::Write;<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-weight:700>use</span><span style=color:#bbb> </span><span style=color:#579>$crate</span>::logger::{<span style=color:#bbb>
</span><span style=color:#bbb>            </span>LoggerTarget,<span style=color:#bbb>
</span><span style=color:#bbb>            </span>LOGGER,<span style=color:#bbb>
</span><span style=color:#bbb>        </span>};<span style=color:#bbb>
</span><span style=color:#bbb>        </span>LOGGER.with(<span style=color:#333>|</span>logger<span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#080;font-weight:700>let</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>logger<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>logger.borrow_mut();<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#080;font-weight:700>match</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span><span style=color:#333>*</span>logger<span style=color:#bbb> </span><span style=color:#080;font-weight:700>as</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>LoggerTarget<span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:#333>|</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>LoggerTarget::Disabled<span style=color:#bbb> </span><span style=color:#333>=&gt;</span><span style=color:#bbb> </span>{},<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:#333>|</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>LoggerTarget::Stderr<span style=color:#bbb> </span><span style=color:#333>=&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>                    </span>eprintln<span style=color:#333>!</span>(<span style=color:#579>$($message</span>)<span style=color:#333>*</span>);<span style=color:#bbb>
</span><span style=color:#bbb>                </span>},<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:#333>|</span><span style=color:#bbb> </span><span style=color:#333>&amp;</span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>LoggerTarget::File(<span style=color:#080;font-weight:700>ref</span><span style=color:#bbb> </span><span style=color:#080;font-weight:700>mut</span><span style=color:#bbb> </span>file)<span style=color:#bbb> </span><span style=color:#333>=&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>                    </span>writeln<span style=color:#333>!</span>(file,<span style=color:#bbb> </span><span style=color:#579>$($message</span>)<span style=color:#333>*</span>)<span style=color:#bbb>
</span><span style=color:#bbb>                        </span>.unwrap_or_else(<span style=color:#333>|</span>err<span style=color:#333>|</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span><span style=color:#bbb>                            </span><span style=color:#333>*</span>logger<span style=color:#bbb> </span><span style=color:#333>=</span><span style=color:#bbb> </span>LoggerTarget::Stderr;<span style=color:#bbb>
</span><span style=color:#bbb>                            </span>eprintln<span style=color:#333>!</span>(<span style=color:#bbb>
</span><span style=color:#bbb>                                </span><span style=background-color:#fff0f0>&#34;Writing to log file failed ({})&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>                                </span>err,<span style=color:#bbb>
</span><span style=color:#bbb>                            </span>);<span style=color:#bbb>
</span><span style=color:#bbb>                        </span>});<span style=color:#bbb>
</span><span style=color:#bbb>                </span>},<span style=color:#bbb>
</span><span style=color:#bbb>            </span>}<span style=color:#bbb>
</span><span style=color:#bbb>        </span>})<span style=color:#bbb>
</span><span style=color:#bbb>    </span>})}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span><span style=color:#bbb></span></code></pre></div><ul><li><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=58515355ef30e10ccbbba7ae72d9d550">Playground</a></li></ul><hr><h1 id=conclusion>Conclusion</h1><p>Well, that was a hell of a journey! I never expected to talk that much about
mutation; at the beginning I just had that itch about people calling <code>&amp;mut _</code> a
mutable reference and then seeing a lot of <code>unsafe</code> code that was unsound
because of that misconception.</p><p>So, I hope you found this long rant interesting, and that it made you, if
possible, more aware of the difficulty of writing actually sound <code>unsafe</code> code
in Rust, while also appreciating the elegance of having delegated the
cornerstone of most languages, aliased mutation, to a special construct in
Rust: <code>UnsafeCell</code>-based <code>struct</code>s. You know understand the beauty of <code>&amp;mut</code>.</p><h3 id=tl-dr>TL,DR</h3><ol><li><p><code>mut</code> is used:</p><ul><li><p>either as a <strong>binding</strong> qualifier to make it &ldquo;unique-aware&rdquo; so that
one can get a unique reference to it (<em>e.g.</em>, to mutate),</p></li><li><p>or in the type of a reference, to express the fact that it such
reference is guaranteed to be unique;</p></li></ul></li><li><p>Thus <code>&amp;mut T</code> does not mean &ldquo;mutable reference to a <code>T</code>&rdquo;, but something
stronger (and thus wildly more dangerous in <code>unsafe</code> code).</p><p>The closest to &ldquo;mutable reference&rdquo; is either the raw mutable pointer
<code>*mut T</code>, or, when talking as a reference, the aliasable <code>&amp;UnsafeCell&lt;T&gt;</code></p><ul><li><p>This is called Interior Mutability (or Aliased Mutability), and can be
used, for instance, to make some struct fields mutable even in an
aliased context (<em>c.f.</em>, <code>Rc</code>).</p></li><li><p>It is possible thanks to the magically sound API of <code>UnsafeCell</code>:</p><p><code>&amp;UnsafeCell&lt;T&gt; -&gt; *mut T</code></p></li></ul></li><li><p>When <code>T</code> is <code>Copy</code> and without multi-threading, this unchecked construct
can be used soundly, which leads to the <code>Cell</code> type, a zero-cost wrapper
for <code>C</code>-like mutation.</p><ul><li><p>For more complex types runtime checks are needed, which gives <code>RefCell</code></p></li><li><p>This can be used to have mutable <code>thread_local!(static)</code>s.</p></li></ul></li><li><p>By using atomic types which are data-race-free, this aliased mutation can
take place from multiple threads in parallel (<code>Sync</code> trait);</p><ul><li><p>Based on these atomic primitives, a runtime-checked <code>Sync</code> wrapper can
be made (<code>RwLock</code> or <code>Mutex</code>), for sound multi-threaded mutation on
even the most complex types.</p></li><li><p>This can be used to have mutable <code>static</code>s / globals.</p></li></ul></li></ol><div class=footnotes><hr><ol><li id=fn:1>except for the fact that a <code>static</code> can be limited to private scopes, such as when defined within a function&rsquo;s body, or when defined within a <code>mod</code> with a non-<code>pub</code> path leading to it.
<a class=footnote-return href=#fnref:1><sup>[return]</sup></a></li><li id=fn:2>See <a href=https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html>Stacked Borrows</a>
<a class=footnote-return href=#fnref:2><sup>[return]</sup></a></li><li id=fn:3>Actually <em>two</em> counters, to work with <code>Weak</code> references. I ignore them in my post, but for those interested, they are invited to read <code>Rc</code>&rsquo;s documentation.
<a class=footnote-return href=#fnref:3><sup>[return]</sup></a></li><li id=fn:4>or written to
<a class=footnote-return href=#fnref:4><sup>[return]</sup></a></li><li id=fn:5>Contrary to most other languages, Rust does not try to feature a rich standard library; on the contrary, to offer a stable and always backwards-compatible language while also allowing continuous improvements, an ecosystem of ever-lasting external crates with semantic versioning is encouraged: <a href=https://crates.io>crates.io</a>. Many of these crates are even maintained by the core team, ensuring the existence of well known and top quality crates, such as <a href=https://docs.rs/crossbeam><code>::crossbeam</code></a>.
<a class=footnote-return href=#fnref:5><sup>[return]</sup></a></li><li id=fn:6>ARM
<a class=footnote-return href=#fnref:6><sup>[return]</sup></a></li><li id=fn:7>For those wondering, generic <code>mem::zeroed</code> (and thus <code>mem:uninitialized</code> too) also belong to that room of shame.
<a class=footnote-return href=#fnref:7><sup>[return]</sup></a></li><li id=fn:8>It relies on using a classic <code>static</code> with <code>UnsafeCell</code> instead of <code>static mut</code>, minor a <code>Sync</code> consideration.
<a class=footnote-return href=#fnref:8><sup>[return]</sup></a></li><li id=fn:9><img src=/img/bmo_upset.gif alt="Upset robot">
<a class=footnote-return href=#fnref:9><sup>[return]</sup></a></li><li id=fn:10>Although <code>Cell::new</code> and <code>RefCell::new</code> are both <code>const fn</code>
<a class=footnote-return href=#fnref:10><sup>[return]</sup></a></li></ol></div></div><div class=prev-next><a class="prev-next-link prev-link" href=/posts/2019-02-24-mutation-part-2-to-mut-or-not-to-mut/><button class="button prev-button">
<span>Prev post</span></button></a></div></main></body></html>